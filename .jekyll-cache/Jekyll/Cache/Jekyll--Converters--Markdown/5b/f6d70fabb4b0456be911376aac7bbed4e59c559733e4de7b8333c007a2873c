I"e<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

<h1 id="模式识别-pattern-recognition">模式识别 Pattern Recognition</h1>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308165314.png" alt="" /></p>

<p><strong>分类：将对象分配到类别（classes）。</strong></p>

<p>维基百科：</p>

<p>模式识别，就是通过计算机用数学技术方法来研究模式的自动处理和判读。我们把环境和客体统称为“模式”。随着计算机技术的发展，人类有可能研究复杂的信息处理过程。</p>

<p>信息处理过程的一个重要形式是生命体对环境及客体的识别。</p>

<p>以光学字元识别之“汉字识别”为例：首先将汉字图像进行处理，抽取主要表达特征并将特征与汉字的代码存在计算机中。就像老师教我们“这个字叫什么、如何写”记在大脑中。这一过程叫做“训练”。识别过程就是将输入的汉字图像经处理后与计算机中的所有字进行比较，找出最相近的字就是识别结果。这一过程叫做“匹配”。</p>

<p>我们如何区分物体？</p>

<ul>
  <li>几何特征，如长宽比、圆度，……。</li>
  <li>颜色特征，如主要色调、平均
饱和度，颜色的差异性，…</li>
</ul>

<p>从实例中学习</p>

<ul>
  <li>收集物体的图像</li>
  <li>为每个物体创建一个特征向量（”模式”）。</li>
  <li>找到一个决策规则来区分不同类别的特征向量之间的类别</li>
  <li>从实例模式中创建一个决策规则的过程，决策规则的过程被称为 “学习”或 “训练”</li>
</ul>

<p>许多方法用于决策规则和学习</p>

<ul>
  <li>线性分类器</li>
  <li>人工神经网络/深度学习</li>
  <li>基于原型的方法</li>
  <li>基于案例的推理</li>
  <li>决策树</li>
  <li>支持向量机</li>
  <li>boosting算法</li>
</ul>

<p>本次我们讨论：
<strong>线性分类器，支持向量机，boosting，决策树，深度学习</strong></p>

<h2 id="线性分类器linear-classification">线性分类器：Linear Classification</h2>

<p>线性分类器是以下类型的函数：</p>

<p>$\vec{x} \mapsto \begin{cases}+1 &amp; \text { if }\langle\vec{x}, \vec{w}\rangle+b \geq 0 \ -1 &amp; \text { otherwise }\end{cases}$</p>

<p>$\vec{w}$是线性分类器的权向量</p>

<p>$b$是分类器的偏置权重</p>

<p>线性分类器将<strong>输入空间</strong>细分为<strong>两个半空间</strong>。 决策边界是一个超平面</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308190140.png" alt="" /></p>

<p>学习任务：</p>

<p>给定一组训练样例：\(\left\{\left(\vec{x}^{(1)}, d^{(1)}\right), \ldots,\left(\vec{x}^{(p)}, d^{(p)}\right)\right\}\)</p>

<p>$d^{(i)}=+1$属于一类的例子（“positive examples”）</p>

<p>$d^{(i)}=-1$对于属于另一类的示例（“negative examples”）</p>

<p>寻找 $\vec{w}$和 使其：</p>

<p>$d^{(i)} \cdot\left(\left\langle\vec{x}^{(i)}, \vec{w}\right\rangle+b\right)&gt;0 \quad$ for all $i \in{1, \ldots, p}$$</p>

<p>许多可能的解决方案，哪一个是最好的？</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308190736.png" alt="img" /></p>

<ul>
  <li>g 和 h，两者都不会产生分类错误</li>
  <li>g 与模式的距离比 h 短</li>
  <li>g 新模式的错误分类风险大于 h</li>
  <li>（未知）类概率分布的支持类似于<a href="https://baike.baidu.com/item/%E5%87%B8%E5%8C%85/179150">凸包</a> 训练示例</li>
</ul>

<p><strong>边距：超平面和训练模式的凸包之间的最小距离</strong></p>

<p>$\rho=\min _{i}\left(d^{(i)} \cdot \frac{\left\langle\vec{x}^{(i)}, \vec{w}\right\rangle+b}{|\vec{w}|}\right)$</p>

<h2 id="支持向量机-svm">支持向量机 SVM</h2>

<p><strong>支持向量机 (SVM)</strong> ：support vector machine (SVM) ： <strong>最大化边距</strong>的线性分类器</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308192211.png" alt="img" /></p>

<p>支持向量机 (SVM)——训练 SVM 意味着解决：</p>

<p>$\begin{array}{ll}\underset{\rho, \vec{w}, b}{\operatorname{maximise}} &amp; \rho^{2} \ \text { subject to } &amp; d^{(i)} \cdot \frac{\left\langle\vec{x}^{(i)}, \vec{w}\right\rangle+b}{|\vec{w}|} \geq \rho \quad \text { for all } i \ &amp; \rho&gt;0\end{array}$</p>

<p>一个自由度：$|\vec{w}|$</p>

<p>简化：</p>

<p>$|\vec{w}|=\frac{1}{\rho}$</p>

<p>$\underset{\vec{w}, b}{\operatorname{minimise}} \frac{1}{2}|\vec{w}|^{2}$
subject to $d^{(i)} \cdot\left(\left\langle\vec{x}^{(i)}, \vec{w}\right\rangle+b\right) \geq 1 \quad$ for all $i$</p>

<p>一个简单的例子：</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308192733.png" alt="img" /></p>

<p>模式是一维的：</p>

<p>正的：5，10；</p>

<p>负的：-1，2</p>

<p>参数：$\vec{w_1},b$</p>

<p>最优化问题：</p>

<p>$\underset{w_{1}, b}{\operatorname{minimise}} \frac{1}{2} w_{1}^{2}$</p>

<p>使其：</p>

<p>$b \geq 1-5 w_{1}$
$b \geq 1-10 w_{1}$
$b \leq-1+w_{1}$
$b \leq-1-2 w_{1}$</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308193206.png" alt="img" /></p>

<p>但是如何训练一个SVM呢？</p>

<p>$\operatorname{minimise}_{\vec{w}, b} \frac{1}{2}|\vec{w}|^{2}$
使其 $d^{(i)} \cdot\left(\left\langle\vec{x}^{(i)}, \vec{w}\right\rangle+b\right) \geq 1 \quad$ for all $i$</p>

<p><strong>…跳过所有细节…</strong></p>

<p>– 应用拉格朗日乘数理论</p>

<p>– 每个训练模式一个拉格朗日乘数</p>

<p>– 解决方案完全由拉格朗日乘数描述</p>

<p>– 许多拉格朗日乘数为零</p>

<p>– 存在计算拉格朗日乘数的算法</p>

<p>解决方案：</p>

<p>• 由支持向量确定的最优分离超平面</p>

<p>• 移除非支持向量不会改变解</p>

<p>• 添加距离大于边距的模式不会改变解</p>

<p>• 移除支持向量会改变解</p>

<p>• 添加距离小于边距的模式会改变解</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308204325.png" alt="" /></p>

<h3 id="容错svm-fault-tolerant-svms">容错SVM Fault-tolerant SVMs</h3>

<ul>
  <li>重叠的类迫使制造错误</li>
</ul>

<p>人为错误$\xi_{i}$</p>

<p>冲突的目标：</p>

<p>使 $\rho$最大化，使$\xi_{i}$ 最小化</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308205120.png" alt="" /></p>

<p>最优化问题：</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308205248.png" alt="" /></p>

<p>C&gt;0：正则化参数控制小误差和大余量之间的平衡（必须手动选择）</p>

<p>容错 SVM 被称为“soft-margin-SVMs”（与“hard-margin-SVMs”相反）</p>

<p><strong>hard-margin-SVMs有类似的解决方案</strong></p>

<p>支持向量是产生单个错误或位于边缘区域边界上的所有模式</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308205416.png" alt="" /></p>

<h3 id="非线性svm-nonlinear-svms">非线性SVM Nonlinear SVMs</h3>

<p>具有非重叠支持的类可能不是线性可分的 → <strong>非线性分类器</strong></p>

<p>• 直接方式：使用圆形/椭圆/非线性曲线进行分类 → 难以分析</p>

<p>• 间接方式：非线性变换数据并改为对变换后的数据进行分类</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308205512.png" alt="" /></p>

<p>非线性问题可能在非线性变换后变为线性问题</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308205543.png" alt="" /></p>

<p>假设非线性变换</p>

\[\Phi:\left\{\begin{array}{l}\mathbb{R}^{n} \rightarrow \mathbb{R}^{m} \\ \vec{x} \mapsto \Phi(\vec{x})=\vec{X}\end{array}\right.\]

<p>找到解决问题的 SVM：</p>

<p>$\underset{\vec{W}, b}{\operatorname{minimise}} \frac{1}{2}|\vec{W}|^{2}$
subject to $d^{(i)} \cdot\left(\left\langle\vec{X}^{(i)}, \vec{W}\right\rangle+b\right) \geq 1 \quad$ for all $i$</p>

<p>在知道拉格朗日乘数的情况下，解决方案完全确定：</p>

<p>​	– 不需要计算</p>

<p>​	– 模式仅作为点积的参数成对出现$\left\langle\vec{X}^{(i)}, \vec{X}^{(j)}\right\rangle=\left\langle\Phi\left(\vec{x}^{(i)}\right), \Phi\left(\vec{x}^{(j)}\right)\right\rangle$</p>

<p>考虑到：$\left\langle\Phi\left(\vec{x}^{(i)}\right), \Phi\left(\vec{x}^{(j)}\right)\right\rangle$</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308210103.png" alt="" /></p>

<p>快捷方式：核函数$K(\vec{x}, \vec{y})=\langle\Phi(\vec{x}), \Phi(\vec{y})\rangle$</p>

<p>通过$\phi$ 消除$K(\vec{x}, \vec{y})$ 来代替$\langle\Phi(\vec{x}), \Phi(\vec{y})\rangle$</p>

<p><a href="https://baike.baidu.com/item/%E6%A0%B8%E5%87%BD%E6%95%B0/4693132">核函数</a>是隐藏复杂性的肮脏技巧吗？</p>

<p>例如：$\Phi(x)=\left(\begin{array}{c}x^{2} \ x\end{array}\right)$</p>

<p>•评估 Φ(x) 和 Φ(y) 需要 2 次乘法</p>

<p>•评估特征空间中的点积需要 2 次乘法和 1 次加法，总共：4 次乘法和 1 次加法</p>

<p>$K(x, y)=\langle\Phi(x), \Phi(y)\rangle=(x y)^{2}+(x y)$</p>

<p>•评估核函数需要 2 次乘法和 1 次加法</p>

<p><strong>一些内核基于无限维的希尔伯特空间</strong></p>

<p>一些有用的核函数：</p>

<ul>
  <li>点积：$K(\vec{x}, \vec{y})=\langle\vec{x}, \vec{y}\rangle$</li>
  <li>多项式核函数：$K(\vec{x}, \vec{y})=(\langle\vec{x}, \vec{y}\rangle)^{q}$ or $(\langle\vec{x}, \vec{y}\rangle+1)^{q}$</li>
  <li>径向基函数 (RBF) 内核 $K(\vec{x}, \vec{y})=e^{-\frac{|\vec{x}-\vec{y}|^{2}}{2 \sigma^{2}}}$</li>
  <li>直方图交叉核（仅适用于直方图特征）\(K(\vec{x}, \vec{y})=\sum_{i} \min \left\{x_{i}, y_{i}\right\}\)</li>
</ul>

<p>内核参数必须手动设置</p>

<p><strong>现在结合所有想法：</strong></p>

<ul>
  <li>
    <p>支持向量机<u>最大化边距</u>以最小化错误分类的风险</p>
  </li>
  <li>
    <p>软边距支持向量机允许<u>个别错误</u>。 由参数 C 控制边距大小和误差之间的平衡</p>
  </li>
  <li>
    <p><u>核函数允许</u>在不改变理论框架的情况下进行<u>非线性分类</u>。 内核类型和内核参数控制非线性程度</p>
  </li>
</ul>

<h3 id="使用svms">使用SVMs</h3>

<ol>
  <li>应用SVM：</li>
</ol>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308211640.png" alt="" /></p>

<ol>
  <li>
    <p>训练SVM：</p>

    <p>我们如何确定 C 和内核？</p>
  </li>
</ol>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308211921.png" alt="" /></p>

<h4 id="评估svm">评估SVM</h4>

<p>错误分类的风险 = “false negative”的风险 + “false positive  ”的风险</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308212031.png" alt="" /></p>

<p>E 未知，但可以从样本集中近似</p>

<p>$E \approx \frac{n_{f n}+n_{f p}}{n}$</p>

<p>– 样本集中的元素数量</p>

<p>– 样本集中的假阳误报数量</p>

<p>– 样本集中的假阴误报数量</p>

<p>• 验证是在样本集（“测试集”、“验证集”）上测试分类器性能的过程</p>

<p>• 选择测试集上误分类率最小的 SVM</p>

<p><strong>• 测试集必须独立于训练集！</strong></p>

<p>• 验证允许比较使用不同 C 值和不同内核训练的 SVM 的性能</p>

<h4 id="交叉验证-cross-validation">交叉验证 Cross Validation</h4>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308213208.png" alt="" /></p>

<p>• 验证过程的缺点：</p>

<p>​	– 仅部分数据用于训练</p>

<p>​	– 仅部分数据用于验证</p>

<p>• k -fold 交叉验证</p>

<p>​	 – 想法：用不同的训练和验证集重复训练/验证过程几次</p>

<p>​	 –  k 是重复次数（介于 2 和模式数之间）</p>

<p>K-fold交叉验证法</p>

<ol>
  <li>
    <p>将模式集细分为K个大小相同的不相干子集</p>
  </li>
  <li>
    <p>对每个子集j重复。
	2.1 从子集1,…,j-1,j+1,…k训练SVM
	2.2. 评估子集j的错误分类率</p>
  </li>
  <li>
    <p>平均错误分类率</p>
  </li>
</ol>

<p>优点：</p>

<p>– 所有模式都用于验证</p>

<p>– 训练集包含一定比例$\frac{k-1}{k}$的模式</p>

<p>如果 k 等于模式总数 → leave-one-out-error</p>

<p>例子 3-fold-cross-validation  ：</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308213511.png" alt="" /></p>

<p>在参数空间中搜索最优参数的可能性，例如</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308213542.png" alt="" /></p>

<p>应该听说过的一些概念：</p>

<ul>
  <li>
    <p>过度拟合：分类器在训练数据上表现良好，但在验证或测试数据上表现不佳</p>
  </li>
  <li>
    <p>欠拟合：分类器在训练和验证数据上表现不佳</p>
  </li>
  <li>
    <p>泛化：从训练示例中学习一个概念 也适用于测试数据，而不仅仅是记住训练示例</p>
  </li>
  <li>
    <p>正则化：“帮助”过度拟合的分类器来提高泛化能力</p>
  </li>
</ul>

<h4 id="实验-数字识别">实验： 数字识别</h4>

<p>对手写数字的图像进行分类（美国邮政编码）</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309085545.png" alt="" /></p>

<p>简化任务：分类——图像显示数字“1”——图像不显示数字“1”</p>

<p>在这里：</p>

<p>– 用于训练和验证：500 个“1”图像，500 个“no-1”图像</p>

<p>– 用于测试：500 个“1”图像，500 个“not-1”数据集图像</p>

<h5 id="第一种方法">第一种方法</h5>

<p>– 二维模式</p>

<ul>
  <li>平均灰度值</li>
  <li>纵横比</li>
</ul>

<p>– 模式重新调整为区间 [-1, +1]</p>

<p>– 带 RBF 内核的软边距 SVM</p>

<p>– 5-fold交叉验证</p>

<p>– 参数空间中的网格搜索：</p>

<p>$10^{-5} \leq C \leq 10^{15}$(on log scale)</p>

<p>$-  10^{-3} \leq \sigma \leq 10^{15} $(on log scale)</p>

<p>准确率： − 交叉验证：93.1% − 测试集：80.3%</p>

<p>支持向量数：167（共 1000 个）</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309093927.png" alt="" /></p>

<h5 id="第二种方法">第二种方法：</h5>

<p>– 添加第三个特征：拟合线到暗像素的平均距离</p>

<p>– 准确度： - 交叉验证：98.5% - 测试集：98.7%</p>

<p>支持向量的数量：95（共 1000 个）</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309094246.png" alt="" /></p>

<p><a href="https://zh.wikipedia.org/zh-hans/%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5">混淆矩阵</a>: (Confusion matrix)</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309094500.png" alt="" /></p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309094742.png" alt="" /></p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309094606.png" alt="" /></p>

<h5 id="第二种方法改进">第二种方法，改进</h5>

<p>– 找到连通分量 (CCL) 并屏蔽除最大段以外的所有部分</p>

<p>– 从预处理图像计算特征</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309094647.png" alt="" /></p>

<p>准确率： − 交叉验证：98.5% − 测试集：99.7%</p>

<p>支持向量数：95（共 1000 个）</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309094726.png" alt="" /></p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309094804.png" alt="" /></p>

<h5 id="第三种方法">第三种方法</h5>

<p>– 将所有图像的大小调整为 28x28 像素，并使用像素的灰度值作为特征</p>

<p>→ 784-维模式</p>

<p>准确率：- 交叉验证：99.0% - 测试集：98.7%</p>

<p>支持向量数量：220（1000 个）</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309094957.png" alt="" /></p>

<h5 id="第三种方法改进">第三种方法改进</h5>

<ul>
  <li>
    <p>观察：很多像素对决策没有贡献，例如 边界像素</p>
  </li>
  <li>
    <p>仅使用所有像素的子集，例如 24x18 子区域 → 432 维图案</p>

    <p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309095209.png" alt="" /></p>
  </li>
</ul>

<p>准确度：- 交叉验证：99.0% - 测试集：99.4%</p>

<p>支持向量数：219（共 1000 个）</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309095130.png" alt="" /></p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309095151.png" alt="" /></p>

<h5 id="第-4-种方法">第 4 种方法</h5>

<p><strong><em>HOG-features</em></strong></p>

<p>– 定向梯度直方图 (Dalal&amp;Triggs, 2005)</p>

<p>使用梯度信息而不是灰度级</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309095854.png" alt="" /></p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309100002.png" alt="" /></p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309100115.png" alt="" /></p>

<p>HOG 排列 4 个相邻单元的归一化块:</p>

\[\vec{V}_{1}=(\underbrace{2,5,1,0,0,0,0,0,}_{\text {from cell } 1} \underbrace{0,17,13,0,0,5,8,0}_{\text {from cell } 2}, \underbrace{15,0,0,0,0,0,0,7}_{\text {from cell } 5}, \underbrace{0,2,4,3,2,3,2,12}_{\text {from cell } 6})\]

<p>规范化描述符：</p>

\[\vec{V}_{1}^{n o r m}=\frac{\vec{V}_{1}}{\left\|\vec{V}_{1}\right\|+\epsilon}\]

<p>组装所有块的描述符：</p>

\[\vec{V}=\left(\vec{V}_{1}^{\text {norm }}, \ldots, \vec{V}_{9}^{\text {norm }}\right)\]

<p>将向量$\vec{V}$应用于 SVM</p>

<p>第四种方法： – 仅使用 HOG 特征 → 288 维模式</p>

<p>准确率： − 交叉验证：99.4% − 测试集：99.7%</p>

<p>支持向量的数量：174（共 1000 个）</p>

<h5 id="第五种方法">第五种方法</h5>

<p><a href="https://zh.wikipedia.org/zh-hans/哈尔特征">哈尔特征</a>（Haar features）</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309101607.png" alt="" /></p>

<p>比较矩形区域的灰度，即红色区域的平均灰度减去蓝色区域的平均灰度</p>

<p>有很多可能的特征</p>

<p>边缘特征：</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309101642.png" alt="" /></p>

<p>线特征：</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309101716.png" alt="" /></p>

<p>棋盘特征：</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309101752.png" alt="" /></p>

<p>中心环绕特征</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309101840.png" alt="" /></p>

<p>对角线方向的特征</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309101903.png" alt="" /></p>

<p><strong>1. 计算哈尔特征</strong>：</p>

<ol>
  <li>简单的直接操作：</li>
</ol>

<p>$s=\sum_{u=u_{0}}^{u_{0}+w-1} \sum_{v=v_{0}}^{v_{0}+h-1} g(u, v)$</p>

<p>用 for 循环实现这一点需要操作</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309102145.png" alt="" /></p>

<ol>
  <li>比较好用的方式</li>
</ol>

<p>$s=\sum_{u=0}^{u_{0}+w-1} \sum_{v=0}^{v_{0}+h-1} g(u, v)-\sum_{u=0}^{u_{0}-1} \sum_{v=0}^{v_{0}+h-1} g(u, v)+\sum_{u=0}^{u_{0}-1} \sum_{v=0}^{v_{0}-1} g(u, v)-\sum_{u=0}^{u_{0}+w-1} \sum_{v=0}^{v_{0}-1} g(u, v)$</p>

<p>​	积分图像：</p>

<p>$I(x, y):=\sum_{u=0}^{x} \sum_{v=0}^{y} g(u, v)$</p>

<p>​	计算 s 需要 4 个操作：</p>

<p>$\begin{array}{c}
s=I\left(u_{0}+w-1, v_{0}+h-1\right)-I\left(u_{0}-1, v_{0}+h-1\right)+ <br />
I\left(u_{0}-1, v_{0}-1\right)-I\left(u_{0}+w-1, v_{0}-1\right)
\end{array}$</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309102650.png" alt="" /></p>

<p><strong>2. 计算积分图像</strong></p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309102838.png" alt="" /></p>

<p>$I(x, y):=\sum_{u=0}^{x} \sum_{v=0}^{y} g(u, v)$</p>

<p>$\begin{aligned}
I(x+1, y+1) &amp;=\sum_{u=0}^{x+1} \sum_{v=0}^{y+1} g(u, v) <br />
&amp;=\sum_{u=0}^{x+1} \sum_{v=0}^{y} g(u, v)+\sum_{u=0}^{x} \sum_{v=0}^{y+1} g(u, v)-\sum_{u=0}^{x} \sum_{v=0}^{y} g(u, v)+g(x+1, y+1) <br />
&amp;=I(x+1, y)+I(x, y+1)-I(x, y)+g(x+1, y+1)
\end{aligned}$</p>

<p>–&gt; 产生一个迭代算法，通过操作计算$O\left(w_{\text {image }} \cdot h_{\text {image }}\right)$整个积分图像</p>

<p>–&gt;如果想计算一个矩形，简单的方法更好；如果要计算许多矩形，积分图像会更好</p>

<p>Haar 特征，在 7x7 位置使用水平和垂直边缘特征 → 98 维模式</p>

<p>准确率： − 交叉验证：99.1% − 测试集：99.4%</p>

<p>支持向量数：109（共 1000 个）</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309103309.png" alt="" /></p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309103325.png" alt="" /></p>

<p><strong>第六种方法：</strong></p>

<p><a href="https://zh.wikipedia.org/zh-hans/%E5%B1%80%E9%83%A8%E4%BA%8C%E5%80%BC%E6%A8%A1%E5%BC%8F">局部二值模式</a> [Local binary patterns (LBP) ]</p>

<ul>
  <li>分析局部灰度变化</li>
  <li>对多个区域执行直方图</li>
</ul>

<ol>
  <li>对于每个相邻像素，检查相邻像素是更亮 (1) 还是更暗 (0)</li>
</ol>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309104104.png" alt="" /></p>

<ol>
  <li>计算块中所有像素的这些数字</li>
</ol>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309104159.png" alt="" /></p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309104218.png" alt="" /></p>

<ol>
  <li>
    <p>制作直方图</p>
  </li>
  <li>
    <p>将所有块的直方图排列在一个向量中</p>
  </li>
</ol>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309104357.png" alt="" /></p>

<p>局部二进制模式 → 4096 维稀疏模式</p>

<p>准确度：- 交叉验证：98.6% - 测试集：99.3%</p>

<p>支持向量的数量：264（共 1000 个）</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309104503.png" alt="" /></p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309104518.png" alt="" /></p>

<h5 id="总结">总结</h5>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309104833.png" alt="" /></p>

<p>见解：</p>

<p>– 训练和测试的准确度不一样</p>

<p>– “智能”特性有很大帮助</p>

<p>– 更多的功能并不意味着更高的准确度</p>

<p>–  “智能”特性包括预处理</p>

<p>– “通用”特征（像素值、HOG、Haar）</p>

<h4 id="图像数据增强data-tuning">图像数据增强Data Tuning</h4>

<p>训练数据的<strong>质量</strong>和<strong>数量</strong>对分类结果的影响很大</p>

<p><strong><em>(一) 我们如何提高数量？</em></strong></p>

<ul>
  <li>– 选择和标记更多图像</li>
  <li>– 搜索数据库/互联网以获取更多训练示例（ImageNet、KITTI、CalTech 数据集、INRIA 数据集、Microsoft COCO，…）</li>
  <li>– 改变亮度、对比度、ROI 中对象位置、旋转的示例</li>
  <li>– 添加抖动（ 随机噪声）</li>
  <li>– 镜像示例，如果对象是对称的</li>
  <li>– 弹性变形 Elastic Distortion</li>
</ul>

<h5 id="弹性变形">弹性变形</h5>

<ol>
  <li>对于每个像素：样本从高斯分布随机偏移</li>
  <li>
    <p>通过与高斯滤波器的卷积平滑移位值</p>
  </li>
  <li>对于每个像素：将像素移动到新位置</li>
</ol>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309111157.png" alt="" /></p>

<p><strong><em>（二）我们如何提高质量？</em></strong></p>

<ul>
  <li>– 检查标签的一致性</li>
  <li>– 标准化/标准化模式</li>
  <li>– 从各种来源/具有不同条件的各种图像序列中获取数据 → 增加模式集中的变化</li>
  <li>– 检查 ROI 是否一致</li>
</ul>

<p>$\begin{array}{l}
x_{i}^{\prime}=\frac{x_{i}-\bar{x}}{s_{x}} <br />
\text { with } \bar{x}=\frac{1}{n} \sum_{i} x_{i} <br />
\text { and } s_{x}=\sqrt{\frac{1}{n} \sum_{i}\left(x_{i}-\bar{x}\right)^{2}}
\end{array}$</p>

<h4 id="多种类分类">多种类分类</h4>

<p>具有两个以上类别的分类</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309111553.png" alt="" /></p>

<h5 id="一对一的方法">一对一的方法：</h5>

<p>为每个类构建一个分类器，对类元素与非类元素进行分类</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309111643.png" alt="" /></p>

<p>克服歧义：</p>

<p><img src="https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309111726.png" alt="" /></p>

:ET