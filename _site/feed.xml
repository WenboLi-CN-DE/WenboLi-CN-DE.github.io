<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>高傲的电工李</title>
    <description>欢迎来到我的个人博客</description>
    <link>https://wenboli-cn-de.github.io/</link>
    <atom:link href="https://wenboli-cn-de.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 03 Mar 2022 05:20:20 +0800</pubDate>
    <lastBuildDate>Thu, 03 Mar 2022 05:20:20 +0800</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>机器视觉-图像分割(第一部分) Segmentation</title>
        <description>&lt;head&gt;
    &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    &lt;/script&gt;
&lt;/head&gt;
&lt;h1 id=&quot;机器视觉-图像分割第一部分&quot;&gt;机器视觉-图像分割(第一部分)&lt;/h1&gt;

&lt;p&gt;在计算机视觉领域， &lt;strong&gt;图像分割&lt;/strong&gt; （segmentation）指的是将数字图像细分为多个图像子区域（像素的集合）（也被称作超像素）的过程。图像分割的目的是&lt;strong&gt;简化或改变图像的表示形式&lt;/strong&gt;，使得图像更容易理解和分析。图像分割通常用于定位图像中的物体和边界（线，曲线等）。更精确的，图像分割是对图像中的每个像素加标签的一个过程，&lt;strong&gt;这一过程使得具有相同标签的像素具有某种共同视觉特性&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;图像分割在&lt;strong&gt;实际中的应用&lt;/strong&gt;：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在卫星图像中定位物体（道路、森林等）

人脸识别

指纹识别

交通控制系统

刹车灯检测 Brake light detection
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;分割的准则&quot;&gt;分割的准则&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;预定义的颜色标准 predefined color criterion&lt;/li&gt;
  &lt;li&gt;邻域准则 neighborhood criterion&lt;/li&gt;
  &lt;li&gt;均匀性准则 homogeneity criterion&lt;/li&gt;
  &lt;li&gt;连通性准则 connectedness criterion&lt;/li&gt;
  &lt;li&gt;空间准则 spatial criterion&lt;/li&gt;
  &lt;li&gt;边界光滑准则 boundary smoothness criterion&lt;/li&gt;
  &lt;li&gt;尺寸准则 size criteria&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302202410.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;预定义的颜色标准-predefined-color-criterion&quot;&gt;预定义的颜色标准 predefined color criterion&lt;/h2&gt;

&lt;p&gt;像素颜色属于一组预定义的”有趣”的颜色，它指定了哪些颜色值是相关的，哪些像素是彩色的。&lt;/p&gt;

&lt;p&gt;例如，我们在下面的足球机器人场地上找到橙色的球。&lt;/p&gt;

&lt;p&gt;橙色的像素点是在HSV值在以下范围的：&lt;/p&gt;

&lt;p&gt;$0^{\circ} \leq H \leq 24^{\circ}, 0.4 \leq S \leq 1,0.4 \leq V \leq 1$&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302193913.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302194516.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注： HSV值(Hue, Saturation, Value)是是根据颜色的直观特性由A. R. Smith在1978年创建的一种颜色空间, 也称六角锥体模型(Hexcone Model)。这个模型中颜色的参数分别是：色调（H），饱和度（S），亮度（V）。&lt;/p&gt;

&lt;p&gt;色调H：用角度度量，取值范围为0°～360°，从红色开始按逆时针方向计算，红色为0°，绿色为120°,蓝色为240°。它们的补色是：黄色为60°，青色为180°,品红为300°；&lt;/p&gt;

&lt;p&gt;饱和度S：取值范围为0.0～1.0；&lt;/p&gt;

&lt;p&gt;亮度V：取值范围为0.0(黑色)～1.0(白色)。&lt;/p&gt;

&lt;p&gt;RGB和CMY颜色模型都是面向硬件的，而HSV（Hue Saturation Value）颜色模型是面向用户的。&lt;/p&gt;

&lt;p&gt;HSV模型的三维表示从RGB立方体演化而来。设想从RGB沿立方体对角线的白色顶点向黑色顶点观察，就可以看到立方体的六边形外形。六边形边界表示色彩，水平轴表示纯度，明度沿垂直轴测量。&lt;/p&gt;

&lt;p&gt;根据颜色进行分割的优缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;非常快速&lt;/li&gt;
  &lt;li&gt;如果事先知道物体的颜色，并且颜色具有辨别力，则&lt;strong&gt;可以应用&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;如果不同的对象共享相同的颜色，则&lt;strong&gt;不适用&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;找到合适的颜色规格通常很麻烦&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;邻域准则-neighborhood-criterion&quot;&gt;邻域准则 neighborhood criterion&lt;/h2&gt;

&lt;p&gt;像素颜色与相邻像素的颜色相似，指定哪些颜色相似，将一段中的所有像素分组，这些像素至少有一个已属于该段的相邻像素&lt;/p&gt;

&lt;p&gt;例如：如果RGB三元组的欧氏距离小于7/255，则像素是相邻的&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302193913.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302195234.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;根据邻域准则进行图片细分的优缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;简单&lt;/li&gt;
  &lt;li&gt;物体的颜色不需要知道&lt;/li&gt;
  &lt;li&gt;对象边界必须是高对比度，内部必须是低对比度&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;模糊的图像可能导致分段不足，嘈杂的图像可能导致分段过度&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;均匀性准则-homogeneity-criterion&quot;&gt;均匀性准则 homogeneity criterion&lt;/h2&gt;

&lt;p&gt;像素颜色与线段的分割颜色相似，指定如何计算平均的颜色并确定两种颜色是否相似。将所有像素分组到一段中，这些像素与分割的平均颜色相似&lt;/p&gt;

&lt;p&gt;例如：与球的平均颜色相似的像素，都属于此分割颜色&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302193913.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302195909.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过均匀性准测进行图像分割的优缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;物体的颜色不需要知道&lt;/li&gt;
  &lt;li&gt;对象的所有部分都必须具有相似的颜色&lt;/li&gt;
  &lt;li&gt;不支持低频率的颜色变化&lt;/li&gt;
  &lt;li&gt;循环定义&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;连通性准则-connectedness-criterion&quot;&gt;连通性准则 connectedness criterion&lt;/h2&gt;

&lt;p&gt;同一段中的所有像素必须连接，即在该段的两个像素之间有一条不离开该段的路径&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302200517.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;优缺点：&lt;/p&gt;

&lt;p&gt;此标准可以与其他标准相结合&lt;/p&gt;

&lt;h2 id=&quot;空间准则-spatial-criterion&quot;&gt;空间准则 spatial criterion&lt;/h2&gt;

&lt;p&gt;被另一部分的像素包围的像素应该属于该部分（另一部分）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302201711.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;优缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;标准与其他标准相结合&lt;/li&gt;
  &lt;li&gt;提高了抗噪性&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;边界光滑准则-boundary-smoothness-criterion&quot;&gt;边界光滑准则 boundary smoothness criterion&lt;/h2&gt;

&lt;p&gt;分割的边界应平滑，而不是参差不齐。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302201944.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302202044.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;优缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;标准与其他标准相结合&lt;/li&gt;
  &lt;li&gt;提高了抗噪性&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;尺寸准则-size-criteria&quot;&gt;尺寸准则 size criteria&lt;/h2&gt;

&lt;p&gt;分割的大小应在一定范围内/不太小/不太大&lt;/p&gt;

&lt;h1 id=&quot;分割算法&quot;&gt;分割算法&lt;/h1&gt;

&lt;p&gt;基础算法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;区域增长 region growing&lt;/li&gt;
  &lt;li&gt;连接组件标记 connected components labeling&lt;/li&gt;
  &lt;li&gt;K-means和mean-shift算法&lt;/li&gt;
  &lt;li&gt;形态学运算 morphological operations&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;更详尽的算法：&lt;/p&gt;

&lt;p&gt;1.&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%B0%B4%E5%B9%B3%E9%9B%86%E6%96%B9%E6%B3%95&quot;&gt;水平集方法&lt;/a&gt;
     level set methods&lt;/p&gt;

&lt;p&gt;2.&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E5%9C%BA&quot;&gt;随机场&lt;/a&gt; 
    random fields&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302202529.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;区域增长-region-growing&quot;&gt;区域增长 region growing&lt;/h2&gt;

&lt;p&gt;区域生长（region growing）是指将成组的像素或区域发展成更大区域的过程。从种子点的集合开始，从这些点的区域增长是通过将与每个种子点有相似属性像强度、灰度级、纹理颜色等的相邻像素合并到此区域。&lt;/p&gt;

&lt;p&gt;核心思想：从一个/多个种子点开始（必须提供种子点）；增量扩展段，直到无法添加更多像素；实现连通性标准+同质性或邻域标准；产生单一的片段。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302203819.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;优缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;易于实现（广度优先搜索）&lt;/li&gt;
  &lt;li&gt;需要一个或多个种子点&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;连接组件标记算法connected-components-labelingccl&quot;&gt;连接组件标记&lt;strong&gt;算法&lt;/strong&gt;connected components labeling（CCL）&lt;/h2&gt;

&lt;p&gt;连接组件标记算法(connected component labeling algorithm)是图像分析中最常用的算法之一，算法的实质是扫描一幅图像的每个像素，对于像素值相同的分为相同的组(group),最终得到图像中所有的像素连通组件。
扫描的方式可以是从上到下，从左到右，对于一幅有N个像素的图像来说，最大连通组件个数为N/2。扫描是基于每个像素单位，对于二值图像而言，连通组件集合可以是V={1|白色}或者V={0|黑色}, 取决于前景色与背景色的不同。
对于灰度图像来说，连图组件像素集合可能是一系列在0 ～ 255之间k的灰度值。&lt;/p&gt;

&lt;p&gt;引用自：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/81959284&quot;&gt;知乎&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;核心思想：创建图像的完整分割；实现连通性标准+邻域标准；仅通过确定与两个相邻像素的相似性，将每个像素分配给分段&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302205133.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们从左上角到右下角逐行访问像素，并立即将它们分配给一个段。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302205336.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当我们访问一个像素（u，v）时，我们已经访问了（u-1，v）和（u，v-1）。&lt;strong&gt;我们比较颜色（u，v）和颜色（u-1，v），颜色（u，v-1），五种情况：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;（u，v）和（u-1，v）处的像素颜色相似，（u，v）和（u，v-1）处的像素颜色不同&lt;/p&gt;

    &lt;p&gt;→ 像素（u，v）和（u-1，v）属于同一段&lt;/p&gt;

    &lt;p&gt;→ 我们将像素（u，v）分配给像素（u-1，v）的部分&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302205643.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;（u，v）和（u-1，v）处的像素颜色不同，（u，v）和（u，v-1）处的像素颜色相似&lt;/p&gt;

    &lt;p&gt;→ 像素（u，v）和（u，v-1）属于同一段&lt;/p&gt;

    &lt;p&gt;→ 我们将像素（u，v）分配给像素（u，v-1）的部分&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302205709.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;（u，v）和（u-1，v）处的像素颜色不同，（u，v）和（u，v-1）处的像素颜色不同&lt;/p&gt;

    &lt;p&gt;→ 为什么像素（u，v）应该属于（u-1，v）或（u，v-1）的段？&lt;/p&gt;

    &lt;p&gt;→ 我们创建一个新段，并为其指定像素（u，v）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302210249.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;（u，v）和（u-1，v）处的像素颜色是相似的，（u，v）和（u，v-1）处的像素颜色是相似的，像素（u-1，v）和（u，v-1）属于同一段。&lt;/p&gt;

    &lt;p&gt;→ 像素（u，v）也属于该部分&lt;/p&gt;

    &lt;p&gt;→ 我们将像素（u，v）分配给该段&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302210306.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;（u，v）和（u-1，v）处的像素颜色相似，（u，v）和（u，v-1）处的像素颜色相似，像素（u-1，v）和（u，v-1）不属于同一段&lt;/p&gt;

    &lt;p&gt;→ 像素（u，v）属于两个相邻的部分&lt;/p&gt;

    &lt;p&gt;→ 我们合并两个相邻的段，并将像素（u，v）分配给合并的段&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302210325.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302210354.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;k均值聚类算法-k-means&quot;&gt;K均值聚类算法 K-means&lt;/h2&gt;

&lt;p&gt;k均值聚类算法（k-means clustering algorithm）是一种迭代求解的聚类分析算法，其步骤是，预将数据分为K组，则随机选取K个对象作为初始的聚类中心，然后计算每个对象与各个种子聚类中心之间的距离，把每个对象分配给距离它最近的聚类中心。聚类中心以及分配给它们的对象就代表一个聚类。每分配一个样本，聚类的聚类中心会根据聚类中现有的对象被重新计算。这个过程将不断重复直到满足某个终止条件。终止条件可以是没有（或最小数目）对象被重新分配给不同的聚类，没有（或最小数目）聚类中心再发生变化，误差平方和局部最小。&lt;/p&gt;

&lt;p&gt;核心思想：图像由相似颜色的区域组成; 寻找颜色的簇; 将每个像素指定给其颜色簇; 实现同质性标准; 创建完整的分割。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302193913.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在上面图片中的颜色簇：绿色，白色，橙色，黑色，品红，蓝，黄色，灰色&lt;/p&gt;

&lt;p&gt;怎么找到颜色簇呢？ 如果我们知道簇的数量 –&amp;gt; k-means 算法&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;随机初始化k原型颜色c1、c2、…、ck（例如，从图像中随机选取像素）&lt;/li&gt;
  &lt;li&gt;将每个像素指定给最相似的原型颜色&lt;/li&gt;
  &lt;li&gt;通过对步骤2中指定的像素颜色进行平均，重新计算原型颜色&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重复第2步和第3步，直到收敛（即第2步中的赋值不再改变）&lt;/p&gt;

    &lt;p&gt;例如：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302211110.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第1步：从两个像素中随机选择颜色；&lt;/p&gt;

&lt;p&gt;第2步：将像素分配给最相似的簇；&lt;/p&gt;

&lt;p&gt;第3步：重新计算原型颜色；&lt;/p&gt;

&lt;p&gt;第2步：重新分配像素；&lt;/p&gt;

&lt;p&gt;第3步：重新计算原型颜色；&lt;/p&gt;

&lt;p&gt;第2步：重新分配像素→ 汇聚&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302211413.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302211438.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302211525.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302211638.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;k-均值算法&lt;/p&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;p&gt;•简单、易于实现&lt;/p&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;p&gt;•必须知道聚类数（k）&lt;/p&gt;

&lt;p&gt;•通常会收敛到次优聚类（取决于初始原型颜色）&lt;/p&gt;

&lt;p&gt;未知聚类数的改进： &lt;strong&gt;mean-shift&lt;/strong&gt; 均值漂移&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;需要颜色的相似性度量&lt;/li&gt;
  &lt;li&gt;对于每个像素p，按如下步骤进行：
1.确定p的颜色并将其分配给变量c
    &lt;ol&gt;
      &lt;li&gt;找到图像中与c相似的所有像素的集合S&lt;/li&gt;
      &lt;li&gt;计算S的平均颜色并将其分配给变量c（不要改变图像中p的像素值
不要改变图像中p的像素值！)&lt;/li&gt;
      &lt;li&gt;重复步骤2和3，直到收敛（即直到步骤2中的S保持不变）。&lt;/li&gt;
      &lt;li&gt;最后，c是像素p所属区段的原型颜色。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例: 沿一个轴排列所有像素颜色（灰度值）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302212227.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第1步：选择目标像素的颜色并初始化c
第2步：找到相似像素的集合S
第3步：计算S的平均颜色并将其分配给c
第2步：重新计算S
第3步：重新计算S的平均颜色并将其分配给c
第2步：重新计算S
第3步：重新计算S的平均颜色并将其分配给c
第2步：重新计算S→收敛&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302212319.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 02 Mar 2022 00:00:00 +0800</pubDate>
        <link>https://wenboli-cn-de.github.io/2022/03/MV6/</link>
        <guid isPermaLink="true">https://wenboli-cn-de.github.io/2022/03/MV6/</guid>
        
        <category>专业</category>
        
        <category>机器视觉</category>
        
        
      </item>
    
      <item>
        <title>机器视觉-曲线拟合(圆和椭圆) Curve Fitting</title>
        <description>&lt;head&gt;
    &lt;script type=&quot;text/javascript&quot; async=&quot;&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;
   &lt;/script&gt;
&lt;/head&gt;

&lt;h1 id=&quot;曲线拟合圆和椭圆&quot;&gt;曲线拟合——圆和椭圆&lt;/h1&gt;

&lt;p&gt;在上一篇文章中，我们总结了视觉识别中对于直线型边缘的拟合。但是如果有的图形边缘是曲线的话应该怎么拟合？ 这一篇博文，我们就对其进行讨论。&lt;/p&gt;

&lt;h2 id=&quot;标准圆&quot;&gt;标准圆&lt;/h2&gt;

&lt;p&gt;首先圆的方程为：\(\left(x-m_{1}\right)^{2}+\left(y-m_{2}\right)^{2}-r^{2} = 0\)&lt;/p&gt;

&lt;p&gt;因为d很小，用趋近的想法来考虑&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220130112538.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那么点(x,y)到圆的欧几里得距离大小为：&lt;/p&gt;

\[d_{E}=\left|\sqrt{\left(x-m_{1}\right)^{2}+\left(y-m_{2}\right)^{2}}-r\right|\]

&lt;p&gt;代数距离为&lt;/p&gt;

\[d_{A}=\left|\left(x-m_{1}\right)^{2}+\left(y-m_{2}\right)^{2}-r^{2}\right|\]

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220130113813.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220130113853.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;根据图知道，欧几里得距离和代数距离是不对称的，靠近圆的点都是相似的。&lt;/p&gt;

&lt;p&gt;两种思路：最小化欧几里得距离和最小化代数距离。解析法&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;最小化欧几里得距离
不能用解析法求解，必须数值优化&lt;/p&gt;

    &lt;p&gt;解析法又称为分析法，它是应用解析式去求解数学模型的方法。 数学中用解析式表示函数或任意数学对象的方法叫解析法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最小化代数距离&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;重写代数距离：\(\begin{aligned} \left(x-m_{1}\right)^{2}+\left(y-m_{2}\right)^{2}-r^{2} &amp;amp;=\left(x^{2}+y^{2}\right)+\left(m_{1}^{2}+m_{2}^{2}-r^{2}\right)+\left(-2 m_{1}\right) x+\left(-2 m_{2}\right) y \\ &amp;amp;=A x+B y+C+\left(x^{2}+y^{2}\right) \\ \text { with } &amp;amp; A=-2 m_{1}, B=-2 m_{2}, C=m_{1}^{2}+m_{2}^{2}-r^{2} \end{aligned}\)&lt;/li&gt;
      &lt;li&gt;最小化：\(\sum_{i=1}^{N}\left(A x_{i}+B y_{i}+C+\left(x_{i}^{2}+y_{i}^{2}\right)\right)^{2}\)&lt;/li&gt;
      &lt;li&gt;偏导数归零: \(\left(\begin{array}{ccc} \sum_{i} x_{i}^{2} &amp;amp; \sum_{i} x_{i} y_{i} &amp;amp; \sum_{i} x_{i} \\ \sum_{i} x_{i} y_{i} &amp;amp; \sum_{i} y_{i}^{2} &amp;amp; \sum_{i} y_{i} \\ \sum_{i} x_{i} &amp;amp; \sum_{i} y_{i} &amp;amp; N \end{array}\right)\left(\begin{array}{l} A \\ B \\ C \end{array}\right)=\left(\begin{array}{c} -\sum_{i} x_{i}\left(x_{i}^{2}+y_{i}^{2}\right) \\ -\sum_{i} y_{i}\left(x_{i}^{2}+y_{i}^{2}\right) \\ -\sum_{i}\left(x_{i}^{2}+y_{i}^{2}\right) \end{array}\right)\)&lt;/li&gt;
      &lt;li&gt;最后得到： \(\begin{aligned} m_{1} &amp;amp;=-\frac{A}{2} \\ m_{2} &amp;amp;=-\frac{B}{2} \\ r^{2} &amp;amp;=m_{1}^{2}+m_{2}^{2}-C \end{aligned}\)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;椭圆&quot;&gt;椭圆&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220130115302.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;椭圆特性：&lt;/p&gt;

&lt;p&gt;长短轴：半长轴r1，半短轴r2；&lt;/p&gt;

&lt;p&gt;中心点：m&lt;/p&gt;

&lt;p&gt;旋转角：θ&lt;/p&gt;

&lt;p&gt;代数表达式：\(\begin{array}{l} A x^{2}+H x y+B y^{2}+G x+F y+C=0 \\ \text { with } 4 A B-H^{2}&amp;gt;0 \end{array}\)&lt;/p&gt;

&lt;p&gt;当消除一个自由度时：\(\begin{array}{l} A=1 \\ \text { or } A+B=1 \\ \text { or } A^{2}+B^{2}+C^{2}+F^{2}+G^{2}+H^{2}=1 \\ \text { or } C=1 \text { (not invariant to translation) } \end{array}\)&lt;/p&gt;

&lt;p&gt;根据椭圆的特性，Fitzgibbon, Pilu, 和 Fisher在1999年提出了基于直接最小二乘的椭圆拟合算法，&lt;/p&gt;

&lt;p&gt;最小化了代数距离(通过最小化的约束条件: $4 A B-H^{2}=1$)&lt;/p&gt;

\[定义：设 A、B 为 n 阶方阵，若存在数λ ，使得方程Ax = λBx 存在 非零解，则称λ 为 A 相对于 B 的广义特征值，x 为 A 相对于 B 的属于 广义特征值λ 的特征向量。\]

\[广义特征值是标准特征值的推广，当B为单位矩阵时，广义标准问题退化为标准特征值问题\]
</description>
        <pubDate>Sun, 30 Jan 2022 00:00:00 +0800</pubDate>
        <link>https://wenboli-cn-de.github.io/2022/01/MV5/</link>
        <guid isPermaLink="true">https://wenboli-cn-de.github.io/2022/01/MV5/</guid>
        
        <category>专业</category>
        
        <category>机器视觉</category>
        
        
      </item>
    
      <item>
        <title>机器视觉-曲线拟合（直线部分） Curve Fitting</title>
        <description>&lt;head&gt;
    &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    &lt;/script&gt;
&lt;/head&gt;

&lt;h1 id=&quot;曲线拟合-curve-fitting&quot;&gt;曲线拟合 Curve Fitting&lt;/h1&gt;

&lt;p&gt;在上一篇文章中，我们讨论了图像的边缘检测，但是边缘检测完毕后存在一个问题就是噪点多，或者换句话说不光滑。&lt;/p&gt;

&lt;p&gt;所以我们再增加一个步骤来使得图像轮廓更加平滑：曲线拟合。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;原始图像–&amp;gt;(通过边缘检测)得到边缘图像–&amp;gt;(通过轮廓探测contour detector)得到坐标值(几何描述)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在进行正式的拟合之前，我们先回顾一下二维几何知识：向量&lt;/p&gt;

&lt;h2 id=&quot;向量&quot;&gt;向量&lt;/h2&gt;

&lt;p&gt;向量知识中有个很重要的概念：点积。&lt;strong&gt;点积的意义主要是表征向量的相似性。值越大代表相似性越好。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220125225003.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;定义：$\langle\vec{p}, \vec{q}\rangle=p_{1} q_{1}+p_{2} q_{2}$  其中p=(p1,p2), q=(q1,q2)&lt;/li&gt;
  &lt;li&gt;双线性：$\langle\alpha \vec{p}+\beta \vec{r}, \gamma \vec{q}+\delta \vec{s}\rangle=\alpha \gamma\langle\vec{p}, \vec{q}\rangle+\alpha \delta\langle\vec{p}, \vec{s}\rangle+\beta \gamma\langle\vec{r}, \vec{q}\rangle+\beta \delta\langle\vec{r}, \vec{s}\rangle$&lt;/li&gt;
  &lt;li&gt;几何定义：$\langle\vec{p}, \vec{q}\rangle=|\vec{p}| \cdot|\vec{q}| \cdot \cos \angle(\vec{p}, \vec{q})$&lt;/li&gt;
  &lt;li&gt;拓展：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;$\langle\vec{p}, \vec{p}\rangle=|\vec{p}|^{2}$， $\langle\vec{p}, \vec{q}\rangle=0 \quad$ if $\vec{p} \perp \vec{q}$&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220125230449.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;线和线段&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们可以把任意向量$\vec{x}$表示为$\vec{p}-\vec{q}$的某一段，我们用$\tau$表示比例，即$\tau(\vec{p}-\vec{q})$, $\tau \in[0,1]$&lt;/p&gt;

&lt;p&gt;那么我们可以得到$\vec{x}=\vec{p}+\tau(\vec{p}-\vec{q})$&lt;/p&gt;

&lt;p&gt;化简得到：&lt;/p&gt;

&lt;p&gt;$\vec{x}=(1-\tau) \vec{p}+\tau \vec{q}, \quad \tau \in[0,1]$&lt;/p&gt;

&lt;p&gt;同理：$\vec{l}$也可通过以上表达：$\vec{l}=(1-\tau) \vec{p}+\tau \vec{q}, \quad \tau \in[0,1]$&lt;/p&gt;

&lt;p&gt;$\vec{l}-\vec{r}=d代表的向量$&lt;/p&gt;

&lt;p&gt;$&amp;lt;\vec{l}-\vec{r},\vec{p}-\vec{q}&amp;gt;=0$     说明d和直线垂直&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;直线的一般形式：&lt;/p&gt;

    &lt;p&gt;$|\vec{n}|=1,\langle\vec{n}, \vec{q}-\vec{p}\rangle=0$ ，$|\vec{n}|为单位向量$&lt;/p&gt;

    &lt;p&gt;$\langle\vec{n}, \vec{x}\rangle=\langle\vec{n},(1-\tau) \vec{p}+\tau \vec{q}\rangle=\langle\vec{n}, \vec{p}\rangle+\tau\langle\vec{n}, \vec{q}-\vec{p}\rangle=\langle\vec{n}, \vec{p}\rangle$&lt;/p&gt;

    &lt;p&gt;$\begin{aligned} 0 &amp;amp;=\langle\vec{n}, \vec{x}\rangle-\langle\vec{n}, \vec{p}\rangle \ &amp;amp;=\langle\vec{n}, \vec{x}\rangle+c \quad \text { (normal form) } \end{aligned}$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;点到直线的距离d：&lt;/p&gt;

\[d=|| \vec{l}-\vec{r} \|=|\langle\vec{n}, \vec{r}\rangle+c|\]
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;用单位向量表示一般向量&quot;&gt;用单位向量表示一般向量：&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220125232803.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;$\vec{v}=\left(\begin{array}{l}v_{1} \ v_{2}\end{array}\right)$&lt;/p&gt;

&lt;p&gt;$\vec{n}=\frac{1}{|\vec{v}|}\left(\begin{array}{c}-v_{2} \ v_{1}\end{array}\right)$&lt;/p&gt;

&lt;p&gt;$\rightarrow \quad|\vec{n}|=1, \vec{n} \perp \vec{v}$&lt;/p&gt;

&lt;p&gt;每个向量都可以用极坐标来表示：&lt;/p&gt;

\[\vec{v}=r \cdot\left(\begin{array}{c}\cos \phi \\ \sin \phi\end{array}\right) \quad，r \geq 0, \phi \in[0,2 \pi)\]

\[\phi=\operatorname{atan}_{2}\left(v_{1}, v_{2}\right)\]

&lt;p&gt;&lt;strong&gt;通过点积可以来判断一个多边形是否面向摄像机（游戏开发中重要的一点）；根据点积来计算光照效果（聚光）；在计算机图学中进行方向性的判断&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;霍夫转换-hough-transform&quot;&gt;霍夫转换 Hough Transform&lt;/h1&gt;

&lt;p&gt;在边缘检测完毕后，我们通过霍夫转换，可以在边缘位图(edge bitmaps)中找到边缘线，每条线可以通过下面的式子来代替：&lt;/p&gt;

&lt;p&gt;$x \cdot \cos \phi+y \cdot \sin \phi+c=0$&lt;/p&gt;

&lt;p&gt;with $0^{\circ} \leq \phi&amp;lt;180^{\circ}$ and $c \in \mathbb{R}$&lt;/p&gt;

&lt;h2 id=&quot;为什么可以这么表示呢&quot;&gt;为什么可以这么表示呢？&lt;/h2&gt;

&lt;p&gt;因为在一般笛卡尔坐标系的直线表达式中，如y = kx+b，存在斜率为无穷大的情况，我们想办法找到一个类似于极坐标的表达方式。通过以上公式表达的方式我们称之为参数空间。在笛卡尔坐标系中的直线表达和 参数空间内的直线表达可以理解为一种映射，可以理解为同一种物体的不同维度的观察。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220125234319.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们知道图中直线和它的垂线(虚线)，一旦直线位置确定，那么其垂线的位置也是确定的。反之亦然。&lt;/p&gt;

&lt;h2 id=&quot;如何找到这种映射关系呢&quot;&gt;如何找到这种映射关系呢？&lt;/h2&gt;

&lt;p&gt;假设有三个点A，B，C我们要判断其是否共线，这里我们假设其共线。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220125202728.png#pic_center&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这条线的方程为&lt;/p&gt;

\[y=-x+2\]

&lt;p&gt;围绕A点可以做无数条直线，B、C同理。那么如果说其中的某三条线重合了，说明ABC共线。&lt;/p&gt;

&lt;p&gt;那么这三条线的极坐标表示也是一样的，在参数空间内就相交于一点。&lt;/p&gt;

&lt;p&gt;那么围绕A点扫描的所有直线的表达式为：&lt;/p&gt;

\[f=0 \times \sin \theta+2 \times \cos \theta, \theta \in[0, \pi]\]

&lt;p&gt;围绕B点扫描的所有直线表达式为：&lt;/p&gt;

\[f=2 \times \sin \theta+0 \times \cos \theta, \theta \in[0, \pi]\]

&lt;p&gt;围绕C点扫描的所有直线表达式为：&lt;/p&gt;

\[f=4 \times \sin \theta-2 \times \cos \theta, \theta \in[0, \pi]\]

&lt;p&gt;然后做出函数图像，我们发现，三个函数交于&lt;/p&gt;

\[\left(\frac{\pi}{4}, \sqrt{2}\right)\]

&lt;p&gt;我们现在知道了，他们相交的直线是以辐角为45°，幅值为$\sqrt{2}$的直线，大家再看笛卡尔坐标系中的直线位置，就明白了其映射关系。大家可以使用其他值作为例子进行体会。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220125202942.png#pic_center&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;霍夫转换的基本步骤&quot;&gt;霍夫转换的基本步骤&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;根据边缘线在参考空间中计算或者画出正弦曲线&lt;/li&gt;
  &lt;li&gt;计算交点&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;值得注意的是，在现实图像处理中，交点并不唯一。（多条线混合在一起）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220126000757.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所以我们只能在&lt;strong&gt;高密度的区域&lt;/strong&gt;中进行找点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用离散累加器单元阵列；&lt;/li&gt;
  &lt;li&gt;对每个单元计算正弦曲线穿过的数量；&lt;/li&gt;
  &lt;li&gt;在累加器阵列中进行局部最大值处理(根据线的参数)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;有点类似我们小时候画三角形的垂直平分线，画完后交不到一点，我们用铅笔继续涂黑。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;在许多边缘上的许多边缘点的霍夫变换&quot;&gt;在许多边缘上的许多边缘点的霍夫变换&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;用0初始化具有足够精度的累加器阵列&lt;/li&gt;
  &lt;li&gt;使得所有满足线方程的累加器单元增加计数（有点拗口，就是计数）&lt;/li&gt;
  &lt;li&gt;在累加器中找到局部最大值（图像中最主要的参数）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在找到线参数后，可以将离线距离小的边缘像素分配到边缘线上。&lt;/p&gt;

&lt;p&gt;但需要做两个工作：1. 确定线的起点和终点。2. 确定允许最大尺寸的间隙。&lt;/p&gt;

&lt;h2 id=&quot;霍夫变换的性质&quot;&gt;霍夫变换的性质&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;结果取决于累积器数组的大小和精度&lt;/li&gt;
  &lt;li&gt;在实践中，确定累积器阵列中的重要峰值可能是困难的&lt;/li&gt;
  &lt;li&gt;梯度方向被忽略&lt;/li&gt;
  &lt;li&gt;累加器数组在”自然场景“中溢出（我猜是计算量过大）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220126002533.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是一张经过霍夫变换后的图，在图中我们可以知道，圆弧部分并没有找到。&lt;/p&gt;

&lt;h1 id=&quot;边缘追踪-edge-following&quot;&gt;边缘追踪 Edge following&lt;/h1&gt;

&lt;p&gt;鉴于霍夫变换的缺点，我们可以通过另一条路线：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;边缘检测edge detection–&amp;gt;边缘追踪edge following–&amp;gt;线段分割polyline segmentation–&amp;gt;直线拟合 line fitting&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;边缘追踪大体思路&quot;&gt;边缘追踪大体思路&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;边缘检测器产生具有边缘像素的位图&lt;/li&gt;
  &lt;li&gt;收集所有边缘像素并按拓扑顺序链接它们&lt;/li&gt;
  &lt;li&gt;使用梯度信息（如果可用）进行链接&lt;/li&gt;
  &lt;li&gt;结果：描述轮廓线的边缘像素列表&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220126003244.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;直线分割-polyline-segmentation&quot;&gt;直线分割 Polyline Segmentation&lt;/h1&gt;

&lt;p&gt;边缘跟踪产生了有序的像素列表，但这些像素列表并不会主动或者自动的生成连线用以表示轮廓，所以我们的任务就是：细分像列表，使子列表可以用线段表示。&lt;/p&gt;

&lt;p&gt;这里有很多的算法，我们只考虑Ramer Douglas Peucker算法，道格拉斯-普克算法&lt;/p&gt;

&lt;h2 id=&quot;道格拉斯-普克算法的基本思路&quot;&gt;道格拉斯-普克算法的基本思路&lt;/h2&gt;

&lt;p&gt;在最远的顶点进行递归细分折线&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220126003732.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从第一个点到最后一个点连成线&lt;/li&gt;
  &lt;li&gt;计算各像素到线的距离&lt;/li&gt;
  &lt;li&gt;若最大的距离大于容差（自己定义的），则在最远的顶点打破边缘列表，并将算法再次应用到两个子列表（列表被打破成两个）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总体思想就是递归思想。&lt;/p&gt;

&lt;h1 id=&quot;直线拟合&quot;&gt;直线拟合&lt;/h1&gt;

&lt;p&gt;由于折线分割和霍夫转换的结果不一定是最优的，所以我们提出直线拟合的算法。&lt;/p&gt;

&lt;p&gt;很容易想到我们以前中学学过的直线拟合算法：最小二乘法&lt;/p&gt;

&lt;h2 id=&quot;最小二乘法&quot;&gt;最小二乘法&lt;/h2&gt;

&lt;p&gt;在这里我们做一下基本的回顾和加深：&lt;/p&gt;

&lt;p&gt;在前面的二维几何知识回顾里，我们知道了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220126004301.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果给定了我们单位向量$\vec{n}$以及$c$, 我们可以计算$\overrightarrow{x_{i}}$到直线的距离为&lt;/p&gt;

\[d_{i}=\left|\left\langle\vec{n}, \vec{x}_{i}\right\rangle+c\right|\]

&lt;p&gt;我们找到最小的$d_{i}$&lt;/p&gt;

&lt;p&gt;&lt;em&gt;不想看推到过程的可以跳到后面，看结论就行了。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;完全最小二乘法：&lt;/p&gt;

\[\underset{\vec{n}, c}{\operatorname{minimise}} \sum_{i=1}^{N} d_{i}^{2}\]

\[\text { subject to }\langle\vec{n}, \vec{n}\rangle=1\]

&lt;p&gt;拉格朗日算子（自行回顾高等数学）&lt;/p&gt;

\[\mathcal{L}(\vec{n}, c, \lambda)=\sum_{i=1}^{N} d_{i}^{2}-\lambda(\langle\vec{n}, \vec{n}\rangle-1)\]

\[=\sum_{i=1}^{N}\left(\left\langle\vec{n}, \vec{x}_{i}\right\rangle+c\right)^{2}-\lambda(\langle\vec{n}, \vec{n}\rangle-1)\]

&lt;p&gt;对$c$进行归零偏导&lt;/p&gt;

\[\frac{\partial \mathcal{L}}{\partial c}=2 \sum_{i=1}^{N}\left\langle\vec{n}, \vec{x}_{i}\right\rangle+2 N c \stackrel{!}{=} 0\]

\[\rightarrow c=-\frac{1}{N} \sum_{i=1}^{N}\left\langle\vec{n}, \vec{x}_{i}\right\rangle=-\frac{1}{N}\left\langle\vec{n}, \sum_{i=1}^{N} \vec{x}_{i}\right\rangle=-\left\langle\vec{n}, \frac{1}{N} \sum_{i=1}^{N} \vec{x}_{i}\right\rangle\]

&lt;p&gt;对$n_{1}$和$n_{2}$归零偏导&lt;/p&gt;

\[\frac{\partial \mathcal{L}}{\partial n_{1}}=2\left(\sum_{i} x_{i, 1}^{2}\right) n_{1}+2\left(\sum_{i} x_{i, 1} x_{i, 2}\right) n_{2}+2\left(\sum_{i} x_{i, 1}\right) c-2 \lambda n_{1} \stackrel{!}{=} 0\]

\[\frac{\partial \mathcal{L}}{\partial n_{2}}=2\left(\sum_{i} x_{i, 1} x_{i, 2}\right) n_{1}+2\left(\sum_{i} x_{i, 2}^{2}\right) n_{2}+2\left(\sum_{i} x_{i, 2}\right) c-2 \lambda n_{2} \stackrel{!}{=} 0\]

&lt;p&gt;替换：&lt;/p&gt;

\[\underbrace{\left(\sum_{i} x_{i, 1}^{2}-\frac{1}{N}\left(\sum_{i} x_{i, 1}\right)^{2}\right)}_{=: \alpha} n_{1}+\underbrace{\left(\sum_{i} x_{i, 1} x_{i, 2}-\frac{1}{N} \sum_{i} x_{i, 1} \sum_{i} x_{i, 2}\right)}_{=: \beta} n_{2}=\lambda n_{1}\]

\[\underbrace{\left(\sum_{i} x_{i, 1} x_{i, 2}-\frac{1}{N} \sum_{i} x_{i, 1} \sum_{i} x_{i, 2}\right)}_{=\beta} n_{1}+\underbrace{\left(\sum_{i} x_{i, 2}^{2}-\frac{1}{N}\left(\sum_{i} x_{i, 2}\right)^{2}\right) n_{2}=\lambda n_{2}}_{=\gamma}\]

&lt;p&gt;用矩阵形式表示：&lt;/p&gt;

\[\left(\begin{array}{ll}
\alpha &amp;amp; \beta \\
\beta &amp;amp; \gamma
\end{array}\right) \vec{n}=\lambda \vec{n}\]

&lt;p&gt;$\lambda$是特征值，$\vec{n}$是特征向量&lt;/p&gt;

&lt;p&gt;两种结果：&lt;/p&gt;

\[\lambda_{1} \geq \lambda_{2} \geq 0\]

&lt;p&gt;$\lambda_{2}$–&amp;gt;最小距离， $\lambda_{1}$–&amp;gt;最大距离。&lt;/p&gt;

&lt;h2 id=&quot;最小二乘法的步骤&quot;&gt;最小二乘法的步骤&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;从所有的边缘像素中计算：   $\sum_{i} x_{i, 1}, \sum_{i} x_{i, 2}, \sum_{i} x_{i, 1}^{2}, \sum_{i} x_{i, 2}^{2}, \sum_{i} x_{i, 1} x_{i, 2}$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;计算矩阵 $\left(\begin{array}{ll}\alpha &amp;amp; \beta \ \beta &amp;amp; \gamma\end{array}\right)$ 的特征向量和特征值，取较小的特征值&lt;/li&gt;
  &lt;li&gt;根据$\vec{n}$计算$c$&lt;/li&gt;
  &lt;li&gt;如果您对线段感兴趣，请根据投影在线上的边缘像素确定起点和终点。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;直线估计&quot;&gt;直线估计&lt;/h2&gt;

&lt;h3 id=&quot;稳健性&quot;&gt;稳健性&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;稳健性是指在估计过程中，拟合过程中，对模型误差的不敏感性。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在最小二乘法中，如果出现异常值，那么拟合的直线很容易被带偏。&lt;/p&gt;

&lt;p&gt;然而异常值在机器视觉中经常出现。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220126011814.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在有两个思路：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;减少总异常值的影响–&amp;gt; M估计，M Estimator&lt;/li&gt;
  &lt;li&gt;忽略异常值–&amp;gt;RANSAC算法&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;m估计&quot;&gt;M估计&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220126012215.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中$\rho$越小，越靠近直线。&lt;/p&gt;

&lt;h3 id=&quot;ransac随机抽样一致算法&quot;&gt;RANSAC随机抽样一致算法&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;一种通过使用观测到的数据点来估计数学模型参数的迭代方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;random sample consensus&lt;/p&gt;

&lt;p&gt;RANSAC算法是一个学习的技巧，通过使用观测数据的随机样本来估计模型参数。RANSAC使用投票机制来寻找优化的拟合结果。每个数据元被用来投票一或多个模型。投票机制基于两点假设：&lt;/p&gt;

&lt;p&gt;（1）噪音大的特征并不能一直单独为某个模型投票&lt;/p&gt;

&lt;p&gt;（2）有足够多的特征来拟合一个好的模型&lt;/p&gt;

&lt;h4 id=&quot;思路&quot;&gt;思路&lt;/h4&gt;

&lt;p&gt;搜索通过尽可能多点靠近的线&lt;/p&gt;

&lt;h4 id=&quot;算法&quot;&gt;算法&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;随机选择两点&lt;/li&gt;
  &lt;li&gt;拟合&lt;/li&gt;
  &lt;li&gt;检查公差带之外的点数（异常值的数量）&lt;/li&gt;
  &lt;li&gt;用不同的点重复这个过程&lt;/li&gt;
  &lt;li&gt;选择异常值数量最少的线&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Tue, 25 Jan 2022 00:00:00 +0800</pubDate>
        <link>https://wenboli-cn-de.github.io/2022/01/MV4/</link>
        <guid isPermaLink="true">https://wenboli-cn-de.github.io/2022/01/MV4/</guid>
        
        <category>专业</category>
        
        <category>机器视觉</category>
        
        
      </item>
    
      <item>
        <title>机器视觉-边缘检测 Edge Detection</title>
        <description>&lt;head&gt;
    &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    &lt;/script&gt;
&lt;/head&gt;
&lt;h1 id=&quot;边缘检测的意义&quot;&gt;边缘检测的意义&lt;/h1&gt;

&lt;p&gt;边缘检测是为了提取图像中主体的轮廓特征.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/Snipaste_2022-01-19_16-48-09.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;灰度边缘的特性&quot;&gt;灰度边缘的特性&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;在明亮和黑暗交接出有明显的改变(hard changes)&lt;/li&gt;
  &lt;li&gt;通常发生在物体的边缘处&lt;/li&gt;
  &lt;li&gt;发生在阴影和纹理处&lt;/li&gt;
  &lt;li&gt;边缘和亮度没有关系&lt;/li&gt;
  &lt;li&gt;人类的视觉皮层的许多部分都在处理灰度边缘&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;灰度&quot;&gt;灰度：&lt;/h2&gt;

&lt;p&gt;把白色与黑色之间按对数关系分成若干级，成为灰度等级。范围一般从0-255，黑色为0.&lt;/p&gt;

&lt;h1 id=&quot;寻找边缘&quot;&gt;寻找边缘&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;边缘是灰度变化最大的地方（其变化率最大，可以通过导数判断）&lt;/p&gt;

    &lt;p&gt;$g(u+\epsilon)-g(u-\epsilon)$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;寻找区域内的g的导数的最大值&lt;/p&gt;

    &lt;p&gt;$\frac{\partial g}{\partial u}=\lim _{\epsilon \rightarrow 0} \frac{g(u+\epsilon)-g(u)}{\epsilon}=\lim _{\epsilon \rightarrow 0} \frac{g(u+\epsilon)-g(u-\epsilon)}{2 \epsilon}$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过差分逼近函数进行近似（因为图片中为各个像素点，无法取极限，通过像素点之间的距离来代替）&lt;/p&gt;

    &lt;p&gt;$\frac{\partial g}{\partial u} \approx \frac{g(u+1)-g(u-1)}{2}$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;近似导数可以实现为带滤波器掩码的卷积&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220119173327.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;prewitt算子sobel算子&quot;&gt;Prewitt算子，Sobel算子&lt;/h2&gt;

&lt;p&gt;Prewitt算子： 利用像素点上下，左右邻点的灰度差，在边缘处达到极值边缘检测&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220119173746.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Sobel算子：与Prewitt算子相比，Sobel对像素的位置的影响做了加权，可以降低位置的影响&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220119173847.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;边缘方向&quot;&gt;边缘方向&lt;/h2&gt;

&lt;p&gt;边缘方向edge direction：灰度梯度指向最大灰度上升的方向（正交方向没有灰度变化）&lt;/p&gt;

&lt;p&gt;$\operatorname{grad} g=\left(\frac{\partial g}{\partial u}, \frac{\partial g}{\partial v}\right)$， $\operatorname{grad} g \perp\left(-\frac{\partial g}{\partial v}, \frac{\partial g}{\partial u}\right)$&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; /&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220119175209.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;canny边缘检测&quot;&gt;Canny边缘检测&lt;/h2&gt;

&lt;h3 id=&quot;1-高斯滤波&quot;&gt;1. 高斯滤波&lt;/h3&gt;

&lt;p&gt;高斯滤波用于降噪，使图像变得平滑。&lt;/p&gt;

&lt;p&gt;使用方法：用高斯矩阵乘以每个像素点及其邻域取其带权重的平均值作为最后的灰度值。&lt;/p&gt;

&lt;h3 id=&quot;2-使用边缘计算算子&quot;&gt;2. 使用边缘计算算子&lt;/h3&gt;

&lt;p&gt;上文中的Prewitt/Sobol算子&lt;/p&gt;

&lt;h3 id=&quot;3-使用非极大值抑制&quot;&gt;3. 使用非极大值抑制&lt;/h3&gt;

&lt;p&gt;非极大值抑制：搜索局部最大值，来抑制非极大值。例如在目标检测过程中，同一目标可能会出现大量候选框，我们通过非极大值抑制的方法来进行唯一化。&lt;/p&gt;

&lt;h3 id=&quot;4-使用双阈值法上下阈值法&quot;&gt;4. 使用双阈值法（上下阈值法）&lt;/h3&gt;

&lt;p&gt;使用一个阈值来检测边缘的效果不好，&lt;/p&gt;

&lt;p&gt;小阈值：太多噪点，&lt;/p&gt;

&lt;p&gt;大阈值：轮廓线连接不上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220119180210.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;二阶微分算子laplace算子&quot;&gt;二阶微分算子：Laplace算子&lt;/h2&gt;

&lt;p&gt;拉普拉斯算子属于最简单的各项同性二阶微分算子，对于二阶图像：&lt;/p&gt;

&lt;p&gt;$\begin{aligned} \nabla^{2} g=&amp;amp; \frac{\partial^{2} g}{(\partial u)^{2}}+\frac{\partial^{2} g}
{(\partial v)^{2}}\end{aligned}$&lt;/p&gt;

&lt;p&gt;变化率最大处（一阶导数）=二阶导数为0&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220119180804.png&quot; height=&quot;330&quot; /&gt;&lt;/p&gt;

&lt;p&gt;近似为拉普拉斯算子：&lt;/p&gt;

&lt;p&gt;一阶导数:&lt;/p&gt;

&lt;p&gt;$\frac{\partial g}{\partial u}(u, v) \approx g(u+1, v)-g(u, v)$&lt;/p&gt;

&lt;p&gt;二阶导数：&lt;/p&gt;

&lt;p&gt;$\begin{aligned} \frac{\partial^{2} g}{(\partial u)^{2}}(u, v) &amp;amp; \approx \frac{\partial g}{\partial u}(u, v)-\frac{\partial g}{\partial u}(u-1, v) \ &amp;amp; \approx g(u+1, v)-2 g(u, v)+g(u-1, v) \end{aligned}$&lt;/p&gt;

&lt;p&gt;$		\frac{\partial^{2} g}{(\partial v)^{2}}(u, v) \approx g(u, v+1)-2 g(u, v)+g(u, v-1)$&lt;/p&gt;

&lt;p&gt;可以得到：&lt;/p&gt;

&lt;p&gt;$\nabla^{2} g \approx g(u+1, v)+g(u-1, v)+g(u, v+1)+g(u, v-1)-4 g(u, v)$&lt;/p&gt;

&lt;p&gt;通过掩码器实现：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220119181824.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是二阶导数带有很多的噪声，所以我们结合高斯平滑，从而形成高斯拉普拉斯算子&lt;/p&gt;

&lt;h3 id=&quot;laplacian-of-gaussian-log&quot;&gt;Laplacian of Gaussian， LoG&lt;/h3&gt;

&lt;p&gt;$\nabla^{2}(G * g)=\left(\nabla^{2} G\right) * g$ $(G$ Gaussian $)$ $G(u, v)=\frac{1}{2 \pi \sigma^{2}} e^{-\frac{1}{2 \sigma^{2}}\left(u^{2}+v^{2}\right)}$ $\begin{aligned} \frac{\partial G}{\partial u} &amp;amp;=\frac{1}{2 \pi \sigma^{2}}\left(-\frac{1}{2 \sigma^{2}}\right) 2 u e^{-\frac{1}{2 \sigma^{2}}\left(u^{2}+v^{2}\right)} \ &amp;amp;=-\frac{u}{\sigma^{2}} G(u, v) \ \frac{\partial^{2} G}{(\partial u)^{2}} &amp;amp;=-\frac{1}{\sigma^{2}} G(u, v)-\frac{u}{\sigma^{2}}\left(-\frac{u}{\sigma^{2}} G(u, v)\right) \ &amp;amp;=\frac{u^{2}-\sigma^{2}}{\sigma^{4}} G(u, v) \ \nabla^{2} G &amp;amp;=\frac{u^{2}+v^{2}-2 \sigma^{2}}{\sigma^{4}} G(u, v) \end{aligned}$&lt;/p&gt;

&lt;p&gt;通过掩码器实现：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220119182303.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;LoG算法可以近似为DoG算法：&lt;/p&gt;

&lt;p&gt;$D o G(u, v)=G_{\sigma_{1}}(u, v)-G_{\sigma_{2}}(u, v)$&lt;/p&gt;

&lt;p&gt;关于DoG的介绍：&lt;a href=&quot;https://stonema.github.io/2018/04/16/LoG%E7%AE%97%E5%AD%90%E4%B8%8EDoG%E7%AE%97%E5%AD%90/&quot;&gt;https://stonema.github.io/2018/04/16/LoG%E7%AE%97%E5%AD%90%E4%B8%8EDoG%E7%AE%97%E5%AD%90/&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 19 Jan 2022 00:00:00 +0800</pubDate>
        <link>https://wenboli-cn-de.github.io/2022/01/MV3.1/</link>
        <guid isPermaLink="true">https://wenboli-cn-de.github.io/2022/01/MV3.1/</guid>
        
        <category>专业</category>
        
        <category>机器视觉</category>
        
        
      </item>
    
      <item>
        <title>央视五集电视专题片《零容忍》</title>
        <description>&lt;h1 id=&quot;第一集不负14亿&quot;&gt;第一集:《不负14亿》&lt;/h1&gt;

&lt;p&gt;链接：&lt;a href=&quot;https://www.bilibili.com/video/BV1eL4y1476T?p=1&quot;&gt;https://www.bilibili.com/video/BV1eL4y1476T?p=1&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;第二集打虎拍蝇&quot;&gt;第二集:《打虎拍蝇》&lt;/h1&gt;

&lt;p&gt;链接：&lt;a href=&quot;https://www.bilibili.com/video/BV1eL4y1476T?p=2&quot;&gt;https://www.bilibili.com/video/BV1eL4y1476T?p=2&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;第三集惩前毖后&quot;&gt;第三集:《惩前毖后》&lt;/h1&gt;

&lt;p&gt;链接：&lt;a href=&quot;https://www.bilibili.com/video/BV1eL4y1476T?p=3&quot;&gt;https://www.bilibili.com/video/BV1eL4y1476T?p=3&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;第四集系统施治&quot;&gt;第四集:《系统施治》&lt;/h1&gt;

&lt;p&gt;链接：&lt;a href=&quot;https://www.bilibili.com/video/BV1eL4y1476T?p=4&quot;&gt;https://www.bilibili.com/video/BV1eL4y1476T?p=4&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;第五集永远在路上&quot;&gt;第五集:《永远在路上》&lt;/h1&gt;

&lt;p&gt;链接：&lt;a href=&quot;https://www.bilibili.com/video/BV1eL4y1476T?p=5&quot;&gt;https://www.bilibili.com/video/BV1eL4y1476T?p=5&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/6/6d/Flag_of_the_Chinese_Communist_Party.svg/1200px-Flag_of_the_Chinese_Communist_Party.svg.png&quot; alt=&quot;Flag&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 18 Jan 2022 00:00:00 +0800</pubDate>
        <link>https://wenboli-cn-de.github.io/2022/01/Politik/</link>
        <guid isPermaLink="true">https://wenboli-cn-de.github.io/2022/01/Politik/</guid>
        
        <category>党政</category>
        
        
      </item>
    
      <item>
        <title>Win系统与Linux进行文件互传</title>
        <description>&lt;h2 id=&quot;1-使用工具winscp&quot;&gt;1. 使用工具Winscp&lt;/h2&gt;
&lt;p&gt;Win系统与Linux在局域网内进行文件互传可以通过Winscp软件进行。
值得注意的是Linux必须开启了ssh服务 对于树莓派来说，开启ssh是很容易的。
但是我的另一个Linux系统是XUbuntu（可以理解为小体积的Ubuntu，由于搭载系统的硬件是一台08年的破iMac, 
尝试Ubuntu无果后选择了替代系统，所以有些服务并未安装，比如此处的ssh服务。），其中并没有ssh服务，必须自己安装。&lt;/p&gt;
&lt;h2 id=&quot;2可能出现的问题&quot;&gt;2.可能出现的问题&lt;/h2&gt;
&lt;p&gt;连接过程可能会提示：
网络错误，连接被（Linux主机IP）拒绝&lt;/p&gt;

&lt;p&gt;Xubuntu安装ssh服务：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo apt-get install openssh-server&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;验证SSH服务器状态：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo systemctl status ssh&lt;/code&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Jan 2022 00:00:00 +0800</pubDate>
        <link>https://wenboli-cn-de.github.io/2022/01/Test0/</link>
        <guid isPermaLink="true">https://wenboli-cn-de.github.io/2022/01/Test0/</guid>
        
        <category>技术</category>
        
        
      </item>
    
  </channel>
</rss>
