<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>高傲的电工李</title>
    <description>欢迎来到我的个人博客</description>
    <link>https://wenboli-cn-de.github.io/</link>
    <atom:link href="https://wenboli-cn-de.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 09 Mar 2022 22:09:35 +0800</pubDate>
    <lastBuildDate>Wed, 09 Mar 2022 22:09:35 +0800</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>机器视觉-模式识别(第二部分) Pattern Recognition</title>
        <description>&lt;head&gt;
    &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    &lt;/script&gt;
&lt;/head&gt;

&lt;h1 id=&quot;模式识别&quot;&gt;模式识别&lt;/h1&gt;

&lt;h2 id=&quot;组合方法-ensemble-methods&quot;&gt;组合方法 Ensemble Methods&lt;/h2&gt;

&lt;p&gt;如果想解决分类问题，应该怎么做？&lt;/p&gt;

&lt;p&gt;– 创建专家：训练分类器&lt;/p&gt;

&lt;p&gt;– 训练几个分类器 → 并构建一个组合&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;集成学习归属于机器学习，他是一种「训练思路」，并不是某种具体的方法或者算法。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;现实生活中，大家都知道「人多力量大」，「3 个臭皮匠顶个诸葛亮」。而集成学习的核心思路就是「人多力量大」，它并没有创造出新的算法，而是把已有的算法进行结合，从而得到更好的效果。&lt;/p&gt;

&lt;p&gt;那组合怎么工作？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309112402.png&quot; style=&quot;zoom:67%;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;k分类器 $c_{1}, c_{2}, \ldots, c_{k}$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将相同的模式应用于所有分类器 → k 个预测&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$\begin{array}{c}
c_{1}(\vec{x}) \in{-1,+1} &lt;br /&gt;
c_{2}(\vec{x}) \in{-1,+1} &lt;br /&gt;
c_{k}(\vec{x}) \in{-1,+1}
\end{array}$&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;总结所有预测并与零进行比较：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$\operatorname{ensemble}(\vec{x})=\operatorname{sign}\left(\sum_{j=1}^{k} c_{j}(\vec{x})\right)$&lt;/p&gt;

&lt;p&gt;最好的四种数字识别方法:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;– (2) “线拟合”特征：99.7%&lt;/li&gt;
  &lt;li&gt;– (3) 像素值：99.4%&lt;/li&gt;
  &lt;li&gt;– (4) HOG 特征：99.7%&lt;/li&gt;
  &lt;li&gt;– (5) Haar 特征：99.4%&lt;/li&gt;
  &lt;li&gt;– (6) LBP 特征：99.3%&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些方法的组合会共享错误（在 1000 个测试示例中）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309112824.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在实验数字识别中, 组合这些方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;组合：线拟合、像素、Haar&lt;/p&gt;

    &lt;p&gt;错误率：5/1000 • 成员错误：3、6、6/1000&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;组合：线拟合、HOG、Haar&lt;/p&gt;

    &lt;p&gt;错误率：1/1000&lt;/p&gt;

    &lt;p&gt;成员错误：3、3、6/1000&lt;/p&gt;

    &lt;p&gt;具有联合特征的 SVM 错误：2/1000&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;组合：线拟合、HOG、LBP&lt;/p&gt;

    &lt;p&gt;错误率 1/1000&lt;/p&gt;

    &lt;p&gt;成员错误：3、3、7/1000&lt;/p&gt;

    &lt;p&gt;具有联合特征的 SVM 错误：5/1000&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;组合所有
错误率 1/1000&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;什么时候组合更有利？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最佳情况：分类器不共享错误&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;组合错误：0&lt;/li&gt;
  &lt;li&gt;每个分类器的错误：100&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309113528.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最差情况：分类器共享所有错误&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;组合错误：150&lt;/li&gt;
  &lt;li&gt;每个分类器的错误：100&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以关键问题就是：&lt;strong&gt;避免分类器共享错误&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;接下来引入：Boosting&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;训练相互依赖的分类器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;u&gt;*第 n+1 号分类器*&lt;/u&gt; 应该专注于被&lt;em&gt;&lt;u&gt;第 1...n号分类器&lt;/u&gt;&lt;/em&gt;   &lt;strong&gt;错误分类&lt;/strong&gt; 的例子&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;boosting&quot;&gt;Boosting&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一、加权训练模式：为每个训练模式引入权重$\gamma_{i} \geq 0$以模拟其重要性&lt;/p&gt;

&lt;p&gt;→ 有必要修改训练算法，例如soft margin SVM。&lt;/p&gt;

&lt;p&gt;$\underset{\vec{w}, b}{\operatorname{minimise}} \frac{1}{2}|\vec{w}|^{2}+C \sum_{i}\left(\gamma_{i} \cdot \xi_{i}\right)$
subject to $d^{(i)} \cdot\left(\left\langle\vec{x}^{(i)}, \vec{w}\right\rangle+b\right) \geq 1-\xi_{i} \quad$ for all $i$ $\xi_{i} \geq 0 \quad$ for all $i$&lt;/p&gt;

&lt;p&gt;如何确定模式权重？
→ 训练分类器后重新计算权重。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;增加被错误分类的模式的权重&lt;/li&gt;
  &lt;li&gt;降低分类良好的模式的权重&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;二、 加权表决&lt;/p&gt;

&lt;p&gt;为每个分类器引入权重$\beta_{k} \geq 0$以模拟其可靠性&lt;/p&gt;

&lt;p&gt;→ 修改投票方案：&lt;/p&gt;

&lt;p&gt;$\operatorname{ensemble}(\vec{x})=\operatorname{sign}\left(\sum_{k} \beta_{k} \cdot \text { vote }_{k}\right)$&lt;/p&gt;

&lt;p&gt;如何确定投票权重？&lt;/p&gt;

&lt;p&gt;→根据分类器的性能选择权重：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;分类器权重大，准确率高&lt;/li&gt;
  &lt;li&gt;权重小，分类器准确率低&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309115611.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;adaboost算法&quot;&gt;AdaBoost算法&lt;/h5&gt;

&lt;p&gt;Boosting是一种集合技术，试图从许多弱分类器中创建一个强分类器。这是通过从训练数据构建模型，然后创建第二个模型来尝试从第一个模型中纠正错误来完成的。添加模型直到完美预测训练集或添加最大数量的模型。&lt;/p&gt;

&lt;p&gt;AdaBoost是第一个为二进制分类开发的真正成功的增强算法。这是理解助力的最佳起点。现代助推方法建立在AdaBoost上，最着名的是随机梯度增强机。&lt;/p&gt;

&lt;p&gt;Adaboost是一种迭代算法，其核心思想是针对同一个训练集训练不同的分类器(弱分类器)，然后把这些弱分类器集合起来，构成一个更强的最终分类器（强分类器）。&lt;/p&gt;

&lt;p&gt;算法：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309115745.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;AdaBoost 的特性：&lt;/p&gt;

&lt;p&gt;集成的训练误差由以下限制：&lt;/p&gt;

\[\prod_{t=1}^{T}\left(2 \sqrt{\epsilon_{t}\left(1-\epsilon_{t}\right)}\right) \leq \exp \left\{-2 \sum_{t=1}^{T}\left(\frac{1}{2}-\epsilon_{t}\right)^{2}\right\}\]

&lt;p&gt;如果 所有的$\epsilon_{t} \leq \lambda&amp;lt;\frac{1}{2}$ 和$T \rightarrow \infty$ AdaBoost 会产生一个完美的分类器&lt;/p&gt;

&lt;h5 id=&quot;haar分类器&quot;&gt;Haar分类器&lt;/h5&gt;

&lt;p&gt;概括来说:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Haar分类器=Haar-like特征+AdaBoost算法+级联+积分图快速计算&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;(1) Haar 特性&lt;/p&gt;

&lt;p&gt;$s=\frac{1}{N_{\text {red }}} \sum_{(u, v) \in \text { red area }} g(u, v)-\frac{1}{N_{\text {blue }}} \sum_{(u, v) \in \text { blue area }} g(u, v)$&lt;/p&gt;

&lt;p&gt;(2) 制作分类器&lt;/p&gt;

&lt;p&gt;$c(s)=\operatorname{sign}(z \cdot(s-\theta))$&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309121157.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;参数：&lt;/p&gt;

&lt;p&gt;$\theta \in \mathbb{R}$ 阈值&lt;/p&gt;

&lt;p&gt;$z \in{+1,-1}$ 方向&lt;/p&gt;

&lt;p&gt;(3)从加权示例训练分类器：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;尝试 θ 和 z 的所有可能值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选择最小化加权误差的值&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$\sum_{s_{i}&amp;lt;\theta, d^{(i)}=z} \gamma_{i}+\sum_{s_{i}&amp;gt;\theta, d^{(i)}=-z} \gamma_{i}$&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309121411.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;(4)具有多种功能的 Haar 分类器：&lt;/p&gt;

&lt;p&gt;​	分类器在一组选项中选择一个 Haar 特征&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309121537.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;boosting-结合haar分类器&quot;&gt;Boosting 结合Haar分类器&lt;/h5&gt;

&lt;p&gt;Idea：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(1) 将 AdaBoost 与 Haar 分类器一起使用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;数字识别任务的测试错误：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第一个分类器：56/1000&lt;/li&gt;
  &lt;li&gt;集合大小 5：54/1000&lt;/li&gt;
  &lt;li&gt;集合大小 50：16/1000&lt;/li&gt;
  &lt;li&gt;集合大小 200：10/1000&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309121744.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309121756.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(2)每个特征产生一个分类器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;例如 像素灰度&lt;/p&gt;

&lt;p&gt;数字识别任务的测试错误：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第一个分类器：193/1000&lt;/li&gt;
  &lt;li&gt;集合大小 5：90/1000&lt;/li&gt;
  &lt;li&gt;集合大小 50：24/1000&lt;/li&gt;
  &lt;li&gt;集合大小 200：18/1000&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309122153.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309122208.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;平衡错误&quot;&gt;平衡错误&lt;/h6&gt;

&lt;p&gt;组合分类器：$\sum_{k}\left(\beta_{k} \cdot c_{k}(\vec{x})\right) \gtrless 0$&lt;/p&gt;

&lt;p&gt;延伸：$\sum_{k}\left(\beta_{k} \cdot c_{k}(\vec{x})\right) \gtrless \delta$&lt;/p&gt;

&lt;p&gt;δ &amp;gt; 0 ：仅当非常确定时才分类为positive&lt;/p&gt;

&lt;p&gt;δ &amp;lt; 0 ：即使不确定，也可以将其归为positive&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;p&gt;具有 Haar 功能的 AdaBoost，组合大小为5&lt;/p&gt;

&lt;p&gt;$\sum_{k}\left(\beta_{k} \cdot c_{k}(\vec{x})\right) \gtrless \delta$&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309123029.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;假设现在有这样一个测试集，测试集中的图片只由大雁和飞机两种图片组成. 假设你的分类系统最终的目的是：能取出测试集中所有飞机的图片，而不是大雁的图片，那么在这个任务中，飞机就是正例，大雁就是反例。&lt;/p&gt;

&lt;p&gt;现在做如下的定义：
True positives : 飞机的图片被正确的识别成了飞机。
True negatives: 大雁的图片没有被识别出来，系统正确地认为它们是大雁。
False positives: 大雁的图片被错误地识别成了飞机。
False negatives: 飞机的图片没有被识别出来，系统错误地认为它们是大雁。&lt;/p&gt;

&lt;p&gt;Precision其实就是在识别出来的图片中，True positives所占的比率：&lt;/p&gt;

&lt;p&gt;$precision = \frac{tp}{tp+fp} = \frac{tp}{n}$&lt;/p&gt;

&lt;p&gt;其中的n代表的是(True positives + False positives)，也就是系统一共识别出来多少照片 。&lt;/p&gt;

&lt;p&gt;$recall = \frac{tp}{tp+fn}$&lt;/p&gt;

&lt;p&gt;Recall 是被正确识别出来的飞机个数与测试集中所有飞机的个数的比值。&lt;/p&gt;

&lt;p&gt;Recall的分母是(True positives + False negatives)，这两个值的和，可以理解为一共有多少张飞机的照片。&lt;/p&gt;

&lt;h5 id=&quot;搜索对象-searching-for-objects&quot;&gt;搜索对象 Searching for Objects&lt;/h5&gt;

&lt;p&gt;我们如何使用分类器在图像中找到对象？&lt;/p&gt;

&lt;p&gt;– 例如 在字母上找到数字“1”；使用“1”的分类器&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309123827.png&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309123945.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;想法：&lt;/p&gt;

&lt;p&gt;将分类器应用于所有图像中所有可能的区域&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;改变区域的位置&lt;/li&gt;
  &lt;li&gt;改变区域的大小&lt;/li&gt;
  &lt;li&gt;改变区域的方向（可选择）。
→ 需要数百万次的试验
效率如何？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;改进的想法：&lt;/p&gt;

&lt;p&gt;使用两个分类器&lt;/p&gt;

&lt;p&gt;分类器1&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;高效&lt;/li&gt;
  &lt;li&gt;不准确&lt;/li&gt;
  &lt;li&gt;高召回率&lt;/li&gt;
  &lt;li&gt;低精度&lt;/li&gt;
  &lt;li&gt;适用于所有领域&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;分类器2&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;低效率&lt;/li&gt;
  &lt;li&gt;精度&lt;/li&gt;
  &lt;li&gt;高召回率&lt;/li&gt;
  &lt;li&gt;高精度&lt;/li&gt;
  &lt;li&gt;适用于由分类器1发现的区域&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;想法可以扩展到一系列许多分类器 → &lt;strong&gt;Viola/Jones 算法&lt;/strong&gt;&lt;/p&gt;

&lt;h6 id=&quot;violajones-approach&quot;&gt;Viola/Jones Approach&lt;/h6&gt;

&lt;p&gt;结合：&lt;/p&gt;

&lt;p&gt;– Haar 分类器&lt;/p&gt;

&lt;p&gt;– AdaBoost&lt;/p&gt;

&lt;p&gt;– 增加集合大小的分类器系列（“级联”）&lt;/p&gt;

&lt;p&gt;– 调整集合以最大化召回率&lt;/p&gt;

&lt;p&gt;– 搜索具有不同区域位置和大小的整个图像&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309124646.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;violajones算法举例&quot;&gt;Viola/Jones算法举例&lt;/h6&gt;

&lt;p&gt;人脸识别&lt;/p&gt;

&lt;p&gt;轮廓线检测&lt;/p&gt;

&lt;h3 id=&quot;决策树decision-trees&quot;&gt;决策树：Decision Trees&lt;/h3&gt;

&lt;p&gt;决策树。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;树状结构，分支因子2&lt;/li&gt;
  &lt;li&gt;内部节点：二进制分类器&lt;/li&gt;
  &lt;li&gt;叶子结点：类标签&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309125041.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从训练示例创建决策树:&lt;/p&gt;

&lt;p&gt;创建具有未知类标签的叶节点作为根节点。&lt;/p&gt;

&lt;p&gt;将所有训练示例分配给它.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309125151.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309125211.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309125440.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;哪些分类器是合适的？&lt;/p&gt;

&lt;p&gt;– 一般来说：全部&lt;/p&gt;

&lt;p&gt;– 类似的想法，例如 boosting：&lt;/p&gt;

&lt;p&gt;通过组合简单分类器创建一个复杂分类器，即阈值分类器: 如使用 Haar 分类器进行数字识别&lt;/p&gt;

&lt;p&gt;数字识别决策树：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309130254.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;改进决策树的技术&quot;&gt;改进决策树的技术&lt;/h6&gt;

&lt;p&gt;&lt;strong&gt;正则化技术Regularization techniques:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;机器学习中的一个核心问题是设计不仅在训练集上误差小，而且在新样本上泛化能力好的算法。许多机器学习算法都需要采取相应的策略来减少测试误差，这些策略被统称为正则化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 早期止损&lt;/strong&gt;
在构建树时使用验证集。当你在验证集上观察到非递减的错误时，停止分割节点。
你观察到验证集上的错误没有减少。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;例如：数字识别的验证误差是。
深度为1的树为54
深度为2的树为37
深度3的树为29
深度4的树为29
深度5的树为29
深度为7的树为36
深度为7的树为37
→ 取深度为3的树&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2.修剪&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先创建完整的决策树。 之后去除不平衡或病态的分支。&lt;/p&gt;

&lt;p&gt;• 几个修剪标准&lt;/p&gt;

&lt;p&gt;• 已经应用过，例如 在决策树算法 C4.5&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.随机决策树和森林&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;u&gt;通过以下方式随机创建决策树&lt;/u&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;随机选择训练数据的子集&lt;/li&gt;
  &lt;li&gt;随机选择作为下一次拆分选项的特征子集&lt;/li&gt;
  &lt;li&gt;随机选择区分阈值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;u&gt;构建许多随机树的集合：&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;→ 随机决策森林&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;创建决策森林&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;– 使用 Haar 特征&lt;/p&gt;

&lt;p&gt;– 随机选择特征和阈值（在 k 个试验中最好）&lt;/p&gt;

&lt;p&gt;– 训练集没有变化&lt;/p&gt;

&lt;p&gt;– 允许深度树&lt;/p&gt;

&lt;p&gt;– 改变集合大小 n&lt;/p&gt;

&lt;p&gt;测试集错误：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309131242.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;比较：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用早期停止训练的决策树：29&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AdaBoost 集成&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;大小 5：54&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;大小 50：16&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;大小 200：10&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SVM：6&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;结合多类别分类器的决策树&quot;&gt;结合多类别分类器的决策树&lt;/h5&gt;

&lt;p&gt;扩展到两个以上的类：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309131610.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;训练分类器以最小化叶节点中的香农熵&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309131637.png&quot; style=&quot;zoom: 50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309131849.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;熵衡量模式集的同质性&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;所有模式属于同一类：熵最小 (0)&lt;/li&gt;
  &lt;li&gt;相同数量的模式属于每个类：熵最大&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309134356.png&quot; style=&quot;zoom: 67%;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 09 Mar 2022 00:00:00 +0800</pubDate>
        <link>https://wenboli-cn-de.github.io/2022/03/MV8.2/</link>
        <guid isPermaLink="true">https://wenboli-cn-de.github.io/2022/03/MV8.2/</guid>
        
        <category>专业</category>
        
        <category>机器视觉</category>
        
        
      </item>
    
      <item>
        <title>机器视觉-模式识别(第一部分) Pattern Recognition</title>
        <description>&lt;head&gt;
    &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    &lt;/script&gt;
&lt;/head&gt;

&lt;h1 id=&quot;模式识别-pattern-recognition&quot;&gt;模式识别 Pattern Recognition&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308165314.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分类：将对象分配到类别（classes）。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;维基百科：&lt;/p&gt;

&lt;p&gt;模式识别，就是通过计算机用数学技术方法来研究模式的自动处理和判读。我们把环境和客体统称为“模式”。随着计算机技术的发展，人类有可能研究复杂的信息处理过程。&lt;/p&gt;

&lt;p&gt;信息处理过程的一个重要形式是生命体对环境及客体的识别。&lt;/p&gt;

&lt;p&gt;以光学字元识别之“汉字识别”为例：首先将汉字图像进行处理，抽取主要表达特征并将特征与汉字的代码存在计算机中。就像老师教我们“这个字叫什么、如何写”记在大脑中。这一过程叫做“训练”。识别过程就是将输入的汉字图像经处理后与计算机中的所有字进行比较，找出最相近的字就是识别结果。这一过程叫做“匹配”。&lt;/p&gt;

&lt;p&gt;我们如何区分物体？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;几何特征，如长宽比、圆度，……。&lt;/li&gt;
  &lt;li&gt;颜色特征，如主要色调、平均
饱和度，颜色的差异性，…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从实例中学习&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;收集物体的图像&lt;/li&gt;
  &lt;li&gt;为每个物体创建一个特征向量（”模式”）。&lt;/li&gt;
  &lt;li&gt;找到一个决策规则来区分不同类别的特征向量之间的类别&lt;/li&gt;
  &lt;li&gt;从实例模式中创建一个决策规则的过程，决策规则的过程被称为 “学习”或 “训练”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;许多方法用于决策规则和学习&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;线性分类器&lt;/li&gt;
  &lt;li&gt;人工神经网络/深度学习&lt;/li&gt;
  &lt;li&gt;基于原型的方法&lt;/li&gt;
  &lt;li&gt;基于案例的推理&lt;/li&gt;
  &lt;li&gt;决策树&lt;/li&gt;
  &lt;li&gt;支持向量机&lt;/li&gt;
  &lt;li&gt;boosting算法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本次我们讨论：
&lt;strong&gt;线性分类器，支持向量机，boosting，决策树，深度学习&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;线性分类器linear-classification&quot;&gt;线性分类器：Linear Classification&lt;/h2&gt;

&lt;p&gt;线性分类器是以下类型的函数：&lt;/p&gt;

&lt;p&gt;$\vec{x} \mapsto \begin{cases}+1 &amp;amp; \text { if }\langle\vec{x}, \vec{w}\rangle+b \geq 0 \ -1 &amp;amp; \text { otherwise }\end{cases}$&lt;/p&gt;

&lt;p&gt;$\vec{w}$是线性分类器的权向量&lt;/p&gt;

&lt;p&gt;$b$是分类器的偏置权重&lt;/p&gt;

&lt;p&gt;线性分类器将&lt;strong&gt;输入空间&lt;/strong&gt;细分为&lt;strong&gt;两个半空间&lt;/strong&gt;。 决策边界是一个超平面&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308190140.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;学习任务：&lt;/p&gt;

&lt;p&gt;给定一组训练样例：\(\left\{\left(\vec{x}^{(1)}, d^{(1)}\right), \ldots,\left(\vec{x}^{(p)}, d^{(p)}\right)\right\}\)&lt;/p&gt;

&lt;p&gt;$d^{(i)}=+1$属于一类的例子（“positive examples”）&lt;/p&gt;

&lt;p&gt;$d^{(i)}=-1$对于属于另一类的示例（“negative examples”）&lt;/p&gt;

&lt;p&gt;寻找 $\vec{w}$和 使其：&lt;/p&gt;

&lt;p&gt;$d^{(i)} \cdot\left(\left\langle\vec{x}^{(i)}, \vec{w}\right\rangle+b\right)&amp;gt;0 \quad$ for all $i \in{1, \ldots, p}$$&lt;/p&gt;

&lt;p&gt;许多可能的解决方案，哪一个是最好的？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308190736.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;g 和 h，两者都不会产生分类错误&lt;/li&gt;
  &lt;li&gt;g 与模式的距离比 h 短&lt;/li&gt;
  &lt;li&gt;g 新模式的错误分类风险大于 h&lt;/li&gt;
  &lt;li&gt;（未知）类概率分布的支持类似于&lt;a href=&quot;https://baike.baidu.com/item/%E5%87%B8%E5%8C%85/179150&quot;&gt;凸包&lt;/a&gt; 训练示例&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;边距：超平面和训练模式的凸包之间的最小距离&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;$\rho=\min _{i}\left(d^{(i)} \cdot \frac{\left\langle\vec{x}^{(i)}, \vec{w}\right\rangle+b}{|\vec{w}|}\right)$&lt;/p&gt;

&lt;h2 id=&quot;支持向量机-svm&quot;&gt;支持向量机 SVM&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;支持向量机 (SVM)&lt;/strong&gt; ：support vector machine (SVM) ： &lt;strong&gt;最大化边距&lt;/strong&gt;的线性分类器&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308192211.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;支持向量机 (SVM)——训练 SVM 意味着解决：&lt;/p&gt;

&lt;p&gt;$\begin{array}{ll}\underset{\rho, \vec{w}, b}{\operatorname{maximise}} &amp;amp; \rho^{2} \ \text { subject to } &amp;amp; d^{(i)} \cdot \frac{\left\langle\vec{x}^{(i)}, \vec{w}\right\rangle+b}{|\vec{w}|} \geq \rho \quad \text { for all } i \ &amp;amp; \rho&amp;gt;0\end{array}$&lt;/p&gt;

&lt;p&gt;一个自由度：$|\vec{w}|$&lt;/p&gt;

&lt;p&gt;简化：&lt;/p&gt;

&lt;p&gt;$|\vec{w}|=\frac{1}{\rho}$&lt;/p&gt;

&lt;p&gt;$\underset{\vec{w}, b}{\operatorname{minimise}} \frac{1}{2}|\vec{w}|^{2}$
subject to $d^{(i)} \cdot\left(\left\langle\vec{x}^{(i)}, \vec{w}\right\rangle+b\right) \geq 1 \quad$ for all $i$&lt;/p&gt;

&lt;p&gt;一个简单的例子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308192733.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;模式是一维的：&lt;/p&gt;

&lt;p&gt;正的：5，10；&lt;/p&gt;

&lt;p&gt;负的：-1，2&lt;/p&gt;

&lt;p&gt;参数：$\vec{w_1},b$&lt;/p&gt;

&lt;p&gt;最优化问题：&lt;/p&gt;

&lt;p&gt;$\underset{w_{1}, b}{\operatorname{minimise}} \frac{1}{2} w_{1}^{2}$&lt;/p&gt;

&lt;p&gt;使其：&lt;/p&gt;

&lt;p&gt;$b \geq 1-5 w_{1}$
$b \geq 1-10 w_{1}$
$b \leq-1+w_{1}$
$b \leq-1-2 w_{1}$&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308193206.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是如何训练一个SVM呢？&lt;/p&gt;

&lt;p&gt;$\operatorname{minimise}_{\vec{w}, b} \frac{1}{2}|\vec{w}|^{2}$
使其 $d^{(i)} \cdot\left(\left\langle\vec{x}^{(i)}, \vec{w}\right\rangle+b\right) \geq 1 \quad$ for all $i$&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;…跳过所有细节…&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;– 应用拉格朗日乘数理论&lt;/p&gt;

&lt;p&gt;– 每个训练模式一个拉格朗日乘数&lt;/p&gt;

&lt;p&gt;– 解决方案完全由拉格朗日乘数描述&lt;/p&gt;

&lt;p&gt;– 许多拉格朗日乘数为零&lt;/p&gt;

&lt;p&gt;– 存在计算拉格朗日乘数的算法&lt;/p&gt;

&lt;p&gt;解决方案：&lt;/p&gt;

&lt;p&gt;• 由支持向量确定的最优分离超平面&lt;/p&gt;

&lt;p&gt;• 移除非支持向量不会改变解&lt;/p&gt;

&lt;p&gt;• 添加距离大于边距的模式不会改变解&lt;/p&gt;

&lt;p&gt;• 移除支持向量会改变解&lt;/p&gt;

&lt;p&gt;• 添加距离小于边距的模式会改变解&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308204325.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;容错svm-fault-tolerant-svms&quot;&gt;容错SVM Fault-tolerant SVMs&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;重叠的类迫使制造错误&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;人为错误$\xi_{i}$&lt;/p&gt;

&lt;p&gt;冲突的目标：&lt;/p&gt;

&lt;p&gt;使 $\rho$最大化，使$\xi_{i}$ 最小化&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308205120.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最优化问题：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308205248.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C&amp;gt;0：正则化参数控制小误差和大余量之间的平衡（必须手动选择）&lt;/p&gt;

&lt;p&gt;容错 SVM 被称为“soft-margin-SVMs”（与“hard-margin-SVMs”相反）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;hard-margin-SVMs有类似的解决方案&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;支持向量是产生单个错误或位于边缘区域边界上的所有模式&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308205416.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;非线性svm-nonlinear-svms&quot;&gt;非线性SVM Nonlinear SVMs&lt;/h3&gt;

&lt;p&gt;具有非重叠支持的类可能不是线性可分的 → &lt;strong&gt;非线性分类器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;• 直接方式：使用圆形/椭圆/非线性曲线进行分类 → 难以分析&lt;/p&gt;

&lt;p&gt;• 间接方式：非线性变换数据并改为对变换后的数据进行分类&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308205512.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;非线性问题可能在非线性变换后变为线性问题&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308205543.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;假设非线性变换&lt;/p&gt;

\[\Phi:\left\{\begin{array}{l}\mathbb{R}^{n} \rightarrow \mathbb{R}^{m} \\ \vec{x} \mapsto \Phi(\vec{x})=\vec{X}\end{array}\right.\]

&lt;p&gt;找到解决问题的 SVM：&lt;/p&gt;

&lt;p&gt;$\underset{\vec{W}, b}{\operatorname{minimise}} \frac{1}{2}|\vec{W}|^{2}$
subject to $d^{(i)} \cdot\left(\left\langle\vec{X}^{(i)}, \vec{W}\right\rangle+b\right) \geq 1 \quad$ for all $i$&lt;/p&gt;

&lt;p&gt;在知道拉格朗日乘数的情况下，解决方案完全确定：&lt;/p&gt;

&lt;p&gt;​	– 不需要计算&lt;/p&gt;

&lt;p&gt;​	– 模式仅作为点积的参数成对出现$\left\langle\vec{X}^{(i)}, \vec{X}^{(j)}\right\rangle=\left\langle\Phi\left(\vec{x}^{(i)}\right), \Phi\left(\vec{x}^{(j)}\right)\right\rangle$&lt;/p&gt;

&lt;p&gt;考虑到：$\left\langle\Phi\left(\vec{x}^{(i)}\right), \Phi\left(\vec{x}^{(j)}\right)\right\rangle$&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308210103.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;快捷方式：核函数$K(\vec{x}, \vec{y})=\langle\Phi(\vec{x}), \Phi(\vec{y})\rangle$&lt;/p&gt;

&lt;p&gt;通过$\phi$ 消除$K(\vec{x}, \vec{y})$ 来代替$\langle\Phi(\vec{x}), \Phi(\vec{y})\rangle$&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E6%A0%B8%E5%87%BD%E6%95%B0/4693132&quot;&gt;核函数&lt;/a&gt;是隐藏复杂性的肮脏技巧吗？&lt;/p&gt;

&lt;p&gt;例如：$\Phi(x)=\left(\begin{array}{c}x^{2} \ x\end{array}\right)$&lt;/p&gt;

&lt;p&gt;•评估 Φ(x) 和 Φ(y) 需要 2 次乘法&lt;/p&gt;

&lt;p&gt;•评估特征空间中的点积需要 2 次乘法和 1 次加法，总共：4 次乘法和 1 次加法&lt;/p&gt;

&lt;p&gt;$K(x, y)=\langle\Phi(x), \Phi(y)\rangle=(x y)^{2}+(x y)$&lt;/p&gt;

&lt;p&gt;•评估核函数需要 2 次乘法和 1 次加法&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一些内核基于无限维的希尔伯特空间&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一些有用的核函数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;点积：$K(\vec{x}, \vec{y})=\langle\vec{x}, \vec{y}\rangle$&lt;/li&gt;
  &lt;li&gt;多项式核函数：$K(\vec{x}, \vec{y})=(\langle\vec{x}, \vec{y}\rangle)^{q}$ or $(\langle\vec{x}, \vec{y}\rangle+1)^{q}$&lt;/li&gt;
  &lt;li&gt;径向基函数 (RBF) 内核 $K(\vec{x}, \vec{y})=e^{-\frac{|\vec{x}-\vec{y}|^{2}}{2 \sigma^{2}}}$&lt;/li&gt;
  &lt;li&gt;直方图交叉核（仅适用于直方图特征）\(K(\vec{x}, \vec{y})=\sum_{i} \min \left\{x_{i}, y_{i}\right\}\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;内核参数必须手动设置&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;现在结合所有想法：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;支持向量机&lt;u&gt;最大化边距&lt;/u&gt;以最小化错误分类的风险&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;软边距支持向量机允许&lt;u&gt;个别错误&lt;/u&gt;。 由参数 C 控制边距大小和误差之间的平衡&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;u&gt;核函数允许&lt;/u&gt;在不改变理论框架的情况下进行&lt;u&gt;非线性分类&lt;/u&gt;。 内核类型和内核参数控制非线性程度&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;使用svms&quot;&gt;使用SVMs&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;应用SVM：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308211640.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;训练SVM：&lt;/p&gt;

    &lt;p&gt;我们如何确定 C 和内核？&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308211921.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;评估svm&quot;&gt;评估SVM&lt;/h4&gt;

&lt;p&gt;错误分类的风险 = “false negative”的风险 + “false positive  ”的风险&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308212031.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;E 未知，但可以从样本集中近似&lt;/p&gt;

&lt;p&gt;$E \approx \frac{n_{f n}+n_{f p}}{n}$&lt;/p&gt;

&lt;p&gt;– 样本集中的元素数量&lt;/p&gt;

&lt;p&gt;– 样本集中的假阳误报数量&lt;/p&gt;

&lt;p&gt;– 样本集中的假阴误报数量&lt;/p&gt;

&lt;p&gt;• 验证是在样本集（“测试集”、“验证集”）上测试分类器性能的过程&lt;/p&gt;

&lt;p&gt;• 选择测试集上误分类率最小的 SVM&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;• 测试集必须独立于训练集！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;• 验证允许比较使用不同 C 值和不同内核训练的 SVM 的性能&lt;/p&gt;

&lt;h4 id=&quot;交叉验证-cross-validation&quot;&gt;交叉验证 Cross Validation&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308213208.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;• 验证过程的缺点：&lt;/p&gt;

&lt;p&gt;​	– 仅部分数据用于训练&lt;/p&gt;

&lt;p&gt;​	– 仅部分数据用于验证&lt;/p&gt;

&lt;p&gt;• k -fold 交叉验证&lt;/p&gt;

&lt;p&gt;​	 – 想法：用不同的训练和验证集重复训练/验证过程几次&lt;/p&gt;

&lt;p&gt;​	 –  k 是重复次数（介于 2 和模式数之间）&lt;/p&gt;

&lt;p&gt;K-fold交叉验证法&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;将模式集细分为K个大小相同的不相干子集&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对每个子集j重复。
	2.1 从子集1,…,j-1,j+1,…k训练SVM
	2.2. 评估子集j的错误分类率&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;平均错误分类率&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;p&gt;– 所有模式都用于验证&lt;/p&gt;

&lt;p&gt;– 训练集包含一定比例$\frac{k-1}{k}$的模式&lt;/p&gt;

&lt;p&gt;如果 k 等于模式总数 → leave-one-out-error&lt;/p&gt;

&lt;p&gt;例子 3-fold-cross-validation  ：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308213511.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在参数空间中搜索最优参数的可能性，例如&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308213542.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;应该听说过的一些概念：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;过度拟合：分类器在训练数据上表现良好，但在验证或测试数据上表现不佳&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;欠拟合：分类器在训练和验证数据上表现不佳&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;泛化：从训练示例中学习一个概念 也适用于测试数据，而不仅仅是记住训练示例&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;正则化：“帮助”过度拟合的分类器来提高泛化能力&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;实验-数字识别&quot;&gt;实验： 数字识别&lt;/h4&gt;

&lt;p&gt;对手写数字的图像进行分类（美国邮政编码）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309085545.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;简化任务：分类——图像显示数字“1”——图像不显示数字“1”&lt;/p&gt;

&lt;p&gt;在这里：&lt;/p&gt;

&lt;p&gt;– 用于训练和验证：500 个“1”图像，500 个“no-1”图像&lt;/p&gt;

&lt;p&gt;– 用于测试：500 个“1”图像，500 个“not-1”数据集图像&lt;/p&gt;

&lt;h5 id=&quot;第一种方法&quot;&gt;第一种方法&lt;/h5&gt;

&lt;p&gt;– 二维模式&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;平均灰度值&lt;/li&gt;
  &lt;li&gt;纵横比&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;– 模式重新调整为区间 [-1, +1]&lt;/p&gt;

&lt;p&gt;– 带 RBF 内核的软边距 SVM&lt;/p&gt;

&lt;p&gt;– 5-fold交叉验证&lt;/p&gt;

&lt;p&gt;– 参数空间中的网格搜索：&lt;/p&gt;

&lt;p&gt;$10^{-5} \leq C \leq 10^{15}$(on log scale)&lt;/p&gt;

&lt;p&gt;$-  10^{-3} \leq \sigma \leq 10^{15} $(on log scale)&lt;/p&gt;

&lt;p&gt;准确率： − 交叉验证：93.1% − 测试集：80.3%&lt;/p&gt;

&lt;p&gt;支持向量数：167（共 1000 个）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309093927.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;第二种方法&quot;&gt;第二种方法：&lt;/h5&gt;

&lt;p&gt;– 添加第三个特征：拟合线到暗像素的平均距离&lt;/p&gt;

&lt;p&gt;– 准确度： - 交叉验证：98.5% - 测试集：98.7%&lt;/p&gt;

&lt;p&gt;支持向量的数量：95（共 1000 个）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309094246.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5&quot;&gt;混淆矩阵&lt;/a&gt;: (Confusion matrix)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309094500.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309094742.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309094606.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;第二种方法改进&quot;&gt;第二种方法，改进&lt;/h5&gt;

&lt;p&gt;– 找到连通分量 (CCL) 并屏蔽除最大段以外的所有部分&lt;/p&gt;

&lt;p&gt;– 从预处理图像计算特征&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309094647.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;准确率： − 交叉验证：98.5% − 测试集：99.7%&lt;/p&gt;

&lt;p&gt;支持向量数：95（共 1000 个）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309094726.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309094804.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;第三种方法&quot;&gt;第三种方法&lt;/h5&gt;

&lt;p&gt;– 将所有图像的大小调整为 28x28 像素，并使用像素的灰度值作为特征&lt;/p&gt;

&lt;p&gt;→ 784-维模式&lt;/p&gt;

&lt;p&gt;准确率：- 交叉验证：99.0% - 测试集：98.7%&lt;/p&gt;

&lt;p&gt;支持向量数量：220（1000 个）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309094957.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;第三种方法改进&quot;&gt;第三种方法改进&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;观察：很多像素对决策没有贡献，例如 边界像素&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;仅使用所有像素的子集，例如 24x18 子区域 → 432 维图案&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309095209.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;准确度：- 交叉验证：99.0% - 测试集：99.4%&lt;/p&gt;

&lt;p&gt;支持向量数：219（共 1000 个）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309095130.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309095151.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;第-4-种方法&quot;&gt;第 4 种方法&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;HOG-features&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;– 定向梯度直方图 (Dalal&amp;amp;Triggs, 2005)&lt;/p&gt;

&lt;p&gt;使用梯度信息而不是灰度级&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309095854.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309100002.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309100115.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;HOG 排列 4 个相邻单元的归一化块:&lt;/p&gt;

\[\vec{V}_{1}=(\underbrace{2,5,1,0,0,0,0,0,}_{\text {from cell } 1} \underbrace{0,17,13,0,0,5,8,0}_{\text {from cell } 2}, \underbrace{15,0,0,0,0,0,0,7}_{\text {from cell } 5}, \underbrace{0,2,4,3,2,3,2,12}_{\text {from cell } 6})\]

&lt;p&gt;规范化描述符：&lt;/p&gt;

\[\vec{V}_{1}^{n o r m}=\frac{\vec{V}_{1}}{\left\|\vec{V}_{1}\right\|+\epsilon}\]

&lt;p&gt;组装所有块的描述符：&lt;/p&gt;

\[\vec{V}=\left(\vec{V}_{1}^{\text {norm }}, \ldots, \vec{V}_{9}^{\text {norm }}\right)\]

&lt;p&gt;将向量$\vec{V}$应用于 SVM&lt;/p&gt;

&lt;p&gt;第四种方法： – 仅使用 HOG 特征 → 288 维模式&lt;/p&gt;

&lt;p&gt;准确率： − 交叉验证：99.4% − 测试集：99.7%&lt;/p&gt;

&lt;p&gt;支持向量的数量：174（共 1000 个）&lt;/p&gt;

&lt;h5 id=&quot;第五种方法&quot;&gt;第五种方法&lt;/h5&gt;

&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/哈尔特征&quot;&gt;哈尔特征&lt;/a&gt;（Haar features）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309101607.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;比较矩形区域的灰度，即红色区域的平均灰度减去蓝色区域的平均灰度&lt;/p&gt;

&lt;p&gt;有很多可能的特征&lt;/p&gt;

&lt;p&gt;边缘特征：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309101642.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;线特征：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309101716.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;棋盘特征：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309101752.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;中心环绕特征&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309101840.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对角线方向的特征&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309101903.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 计算哈尔特征&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;简单的直接操作：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;$s=\sum_{u=u_{0}}^{u_{0}+w-1} \sum_{v=v_{0}}^{v_{0}+h-1} g(u, v)$&lt;/p&gt;

&lt;p&gt;用 for 循环实现这一点需要操作&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309102145.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;比较好用的方式&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;$s=\sum_{u=0}^{u_{0}+w-1} \sum_{v=0}^{v_{0}+h-1} g(u, v)-\sum_{u=0}^{u_{0}-1} \sum_{v=0}^{v_{0}+h-1} g(u, v)+\sum_{u=0}^{u_{0}-1} \sum_{v=0}^{v_{0}-1} g(u, v)-\sum_{u=0}^{u_{0}+w-1} \sum_{v=0}^{v_{0}-1} g(u, v)$&lt;/p&gt;

&lt;p&gt;​	积分图像：&lt;/p&gt;

&lt;p&gt;$I(x, y):=\sum_{u=0}^{x} \sum_{v=0}^{y} g(u, v)$&lt;/p&gt;

&lt;p&gt;​	计算 s 需要 4 个操作：&lt;/p&gt;

&lt;p&gt;$\begin{array}{c}
s=I\left(u_{0}+w-1, v_{0}+h-1\right)-I\left(u_{0}-1, v_{0}+h-1\right)+ &lt;br /&gt;
I\left(u_{0}-1, v_{0}-1\right)-I\left(u_{0}+w-1, v_{0}-1\right)
\end{array}$&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309102650.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 计算积分图像&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309102838.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;$I(x, y):=\sum_{u=0}^{x} \sum_{v=0}^{y} g(u, v)$&lt;/p&gt;

&lt;p&gt;$\begin{aligned}
I(x+1, y+1) &amp;amp;=\sum_{u=0}^{x+1} \sum_{v=0}^{y+1} g(u, v) &lt;br /&gt;
&amp;amp;=\sum_{u=0}^{x+1} \sum_{v=0}^{y} g(u, v)+\sum_{u=0}^{x} \sum_{v=0}^{y+1} g(u, v)-\sum_{u=0}^{x} \sum_{v=0}^{y} g(u, v)+g(x+1, y+1) &lt;br /&gt;
&amp;amp;=I(x+1, y)+I(x, y+1)-I(x, y)+g(x+1, y+1)
\end{aligned}$&lt;/p&gt;

&lt;p&gt;–&amp;gt; 产生一个迭代算法，通过操作计算$O\left(w_{\text {image }} \cdot h_{\text {image }}\right)$整个积分图像&lt;/p&gt;

&lt;p&gt;–&amp;gt;如果想计算一个矩形，简单的方法更好；如果要计算许多矩形，积分图像会更好&lt;/p&gt;

&lt;p&gt;Haar 特征，在 7x7 位置使用水平和垂直边缘特征 → 98 维模式&lt;/p&gt;

&lt;p&gt;准确率： − 交叉验证：99.1% − 测试集：99.4%&lt;/p&gt;

&lt;p&gt;支持向量数：109（共 1000 个）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309103309.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309103325.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第六种方法：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E5%B1%80%E9%83%A8%E4%BA%8C%E5%80%BC%E6%A8%A1%E5%BC%8F&quot;&gt;局部二值模式&lt;/a&gt; [Local binary patterns (LBP) ]&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;分析局部灰度变化&lt;/li&gt;
  &lt;li&gt;对多个区域执行直方图&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;对于每个相邻像素，检查相邻像素是更亮 (1) 还是更暗 (0)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309104104.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;计算块中所有像素的这些数字&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309104159.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309104218.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;制作直方图&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将所有块的直方图排列在一个向量中&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309104357.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;局部二进制模式 → 4096 维稀疏模式&lt;/p&gt;

&lt;p&gt;准确度：- 交叉验证：98.6% - 测试集：99.3%&lt;/p&gt;

&lt;p&gt;支持向量的数量：264（共 1000 个）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309104503.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309104518.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;总结&quot;&gt;总结&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309104833.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;见解：&lt;/p&gt;

&lt;p&gt;– 训练和测试的准确度不一样&lt;/p&gt;

&lt;p&gt;– “智能”特性有很大帮助&lt;/p&gt;

&lt;p&gt;– 更多的功能并不意味着更高的准确度&lt;/p&gt;

&lt;p&gt;–  “智能”特性包括预处理&lt;/p&gt;

&lt;p&gt;– “通用”特征（像素值、HOG、Haar）&lt;/p&gt;

&lt;h4 id=&quot;图像数据增强data-tuning&quot;&gt;图像数据增强Data Tuning&lt;/h4&gt;

&lt;p&gt;训练数据的&lt;strong&gt;质量&lt;/strong&gt;和&lt;strong&gt;数量&lt;/strong&gt;对分类结果的影响很大&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;(一) 我们如何提高数量？&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;– 选择和标记更多图像&lt;/li&gt;
  &lt;li&gt;– 搜索数据库/互联网以获取更多训练示例（ImageNet、KITTI、CalTech 数据集、INRIA 数据集、Microsoft COCO，…）&lt;/li&gt;
  &lt;li&gt;– 改变亮度、对比度、ROI 中对象位置、旋转的示例&lt;/li&gt;
  &lt;li&gt;– 添加抖动（ 随机噪声）&lt;/li&gt;
  &lt;li&gt;– 镜像示例，如果对象是对称的&lt;/li&gt;
  &lt;li&gt;– 弹性变形 Elastic Distortion&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;弹性变形&quot;&gt;弹性变形&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;对于每个像素：样本从高斯分布随机偏移&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过与高斯滤波器的卷积平滑移位值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;对于每个像素：将像素移动到新位置&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309111157.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;（二）我们如何提高质量？&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;– 检查标签的一致性&lt;/li&gt;
  &lt;li&gt;– 标准化/标准化模式&lt;/li&gt;
  &lt;li&gt;– 从各种来源/具有不同条件的各种图像序列中获取数据 → 增加模式集中的变化&lt;/li&gt;
  &lt;li&gt;– 检查 ROI 是否一致&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$\begin{array}{l}
x_{i}^{\prime}=\frac{x_{i}-\bar{x}}{s_{x}} &lt;br /&gt;
\text { with } \bar{x}=\frac{1}{n} \sum_{i} x_{i} &lt;br /&gt;
\text { and } s_{x}=\sqrt{\frac{1}{n} \sum_{i}\left(x_{i}-\bar{x}\right)^{2}}
\end{array}$&lt;/p&gt;

&lt;h4 id=&quot;多种类分类&quot;&gt;多种类分类&lt;/h4&gt;

&lt;p&gt;具有两个以上类别的分类&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309111553.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;一对一的方法&quot;&gt;一对一的方法：&lt;/h5&gt;

&lt;p&gt;为每个类构建一个分类器，对类元素与非类元素进行分类&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309111643.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;克服歧义：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220309111726.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 08 Mar 2022 00:00:00 +0800</pubDate>
        <link>https://wenboli-cn-de.github.io/2022/03/MV8.1/</link>
        <guid isPermaLink="true">https://wenboli-cn-de.github.io/2022/03/MV8.1/</guid>
        
        <category>专业</category>
        
        <category>机器视觉</category>
        
        
      </item>
    
      <item>
        <title>机器视觉-图像分割(第二部分) Segmentation</title>
        <description>&lt;head&gt;
    &lt;script type=&quot;text/javascript&quot; async=&quot;&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;
   &lt;/script&gt;
&lt;/head&gt;

&lt;h1 id=&quot;形态学运算-morphological-operations&quot;&gt;形态学运算 Morphological Operations&lt;/h1&gt;

&lt;p&gt;对于图像具有的问题：孔洞， 参差不齐的轮廓，间隙，微小区域等，我们提出了形态学运算。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;两个关键概念&lt;/strong&gt;：扩展和缩小区域：&lt;/p&gt;

&lt;p&gt;——&lt;strong&gt;腐蚀erosion：&lt;/strong&gt; 将区域缩小一个像素&lt;/p&gt;

&lt;p&gt;——&lt;strong&gt;膨胀dilation&lt;/strong&gt;：将区域扩大一个像素&lt;/p&gt;

&lt;p&gt;最基本的形态学运算是膨胀和腐蚀。膨胀指将像素添加到图像中对象的边界，而腐蚀指删除对象边界上的像素。&lt;/p&gt;

&lt;p&gt;现在我们假设：&lt;/p&gt;

&lt;p&gt;背景的像素用0编码，前景像素用大于1的数字编码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308094220.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;center&gt;如图是四个相邻的像素 &lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308094331.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;center&gt;八个相邻的像素 &lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;image/2022-02-08-MV6.1/1646729074143.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;center&gt;24个相邻的像素八个相邻的像素 &lt;/center&gt;

&lt;p&gt;&lt;strong&gt;腐蚀&lt;/strong&gt;：&lt;/p&gt;

\[\begin{aligned} \operatorname{erode}\{g\}(u, v)=\min \{&amp;amp; g(u, v) \\ &amp;amp; g(u+1, v), g(u+1, v+1) \\ &amp;amp; g(u, v+1), g(u-1, v+1) \\ &amp;amp; g(u-1, v), g(u-1, v-1) \\ &amp;amp;g(u, v-1), g(u+1, v-1)\} \end{aligned}\]

&lt;p&gt;取相邻的最小值&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;膨胀&lt;/strong&gt;：&lt;/p&gt;

\[\begin{aligned} \operatorname{dilate}\{g\}(u, v)=\max &amp;amp;\{g(u, v)\\ &amp;amp; g(u+1, v), g(u+1, v+1), \\ &amp;amp; g(u, v+1), g(u-1, v+1) \\ &amp;amp; g(u-1, v), g(u-1, v-1) \\ &amp;amp;g(u, v-1), g(u+1, v-1)\} \end{aligned}\]

&lt;p&gt;取相邻的最大值&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308095334.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308095446.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后一个巧妙地知识：腐蚀和膨胀能够结合&lt;/p&gt;

&lt;p&gt;—— 闭合colsing：先膨胀，再腐蚀&lt;/p&gt;

&lt;p&gt;在不改变区域整体延伸的情况下填充间隙和孔洞&lt;/p&gt;

&lt;p&gt;—— 开放opening：先腐蚀，再膨胀&lt;/p&gt;

&lt;p&gt;去除薄区域而不改变大区域的整体延伸&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308095744.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;image/2022-02-08-MV6.1/1646729944200.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;到目前为止，我们的分割是：&lt;/p&gt;

&lt;p&gt;——分割基于颜色（或灰度值）&lt;/p&gt;

&lt;p&gt;——不同的颜色表示和不同的相似度测量&lt;/p&gt;

&lt;p&gt;问题是：我们如何分割颜色不显著的图像&lt;/p&gt;

&lt;p&gt;例如：将图像分割成相同阴影的区域&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308100342.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那我们分割图像又需要什么呢？&lt;/p&gt;

&lt;p&gt;对每个像素：对该像素的描述（图像特征）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如：颜色&lt;/li&gt;
  &lt;li&gt;如：纹理信息&lt;/li&gt;
  &lt;li&gt;如：点的深度（三维扫描仪/立体视觉)&lt;/li&gt;
  &lt;li&gt;如：像素的运动（光流）。&lt;/li&gt;
  &lt;li&gt;如：描述像素是否属于某些物体类别的特征&lt;/li&gt;
  &lt;li&gt;再例如，这些特征的组合&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在上述例子中，我们又将找到了什么样子的图像特征呢：&lt;/p&gt;

&lt;p&gt;图像特征：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;颜色和灰度等级不突出&lt;/li&gt;
  &lt;li&gt;线条的方向是突出的&lt;/li&gt;
  &lt;li&gt;例如
    &lt;ul&gt;
      &lt;li&gt;计算灰度等级的梯度&lt;/li&gt;
      &lt;li&gt;确定主要的梯度方向
在像素周围的局部环境中&lt;/li&gt;
      &lt;li&gt;用2维矢量表示方向&lt;/li&gt;
      &lt;li&gt;矢量的长度与平均梯度长度成正比
梯度长度&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们的准则和算法：&lt;/p&gt;

&lt;p&gt;• 邻域标准&lt;/p&gt;

&lt;p&gt;• 最小分段大小&lt;/p&gt;

&lt;p&gt;• CCL&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308100853.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308100930.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;水平集方法-let-set-methods&quot;&gt;水平集方法 Let Set Methods&lt;/h1&gt;

&lt;p&gt;这个方法我的个人理解是通过一段任意封闭的曲线进行扩张，当扩张到图像梯度明显的地方开始放缓扩张速度直到停止，从而形成一段对具有对明显图像特征的区域进行包络。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308102404.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308102347.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308102429.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;二类图像分割：&lt;/p&gt;

&lt;p&gt;表示分类任务中有两个类别，比如我们想识别一幅图片是不是猫。也就是说，训练一个分类器，输入一幅图片，用特征向量x表示，输出是不是猫，用y=0或1表示。二类分类是假设每个样本都被设置了一个且仅有一个标签 0 或者 1。&lt;/p&gt;

&lt;p&gt;这类分割的特点：&lt;/p&gt;

&lt;p&gt;所有像素的集合都属于分割；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;指示函数indicator function：&lt;/strong&gt;&lt;/p&gt;

\[\phi(\vec{x}) \begin{cases}&amp;lt;0 &amp;amp; \text { if pixel } \vec{x} \text { belongs to segment } \\ &amp;gt;0 &amp;amp; \text { if pixel } \vec{x} \text { belongs to background }\end{cases}\]

&lt;p&gt;边界线&lt;/p&gt;

&lt;p&gt;有符号距离函数&lt;/p&gt;

\[|\phi(\vec{x})|= \text{ distance of } \vec{x} \text{ from contour}\]

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308103407.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;轮廓点：&lt;/p&gt;

\[\phi(\vec{x})= 0\]

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308103807.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308103922.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对有符号距离函数的时间演化建模: 
\(\phi(\vec{x}, t)\)&lt;/p&gt;

&lt;p&gt;随着时间的推移跟踪边界上的一个点\(\vec{x}(t)\)&lt;/p&gt;

&lt;p&gt;显然：&lt;/p&gt;

\[\phi(\vec{x}(t), t)=0\]

&lt;p&gt;for all \(t\)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308104216.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308104804.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由上可得：&lt;/p&gt;

\[\frac{\partial \phi}{\partial t}=-\nabla \phi \cdot \frac{\partial \vec{x}}{\partial t}\]

&lt;p&gt;水平集方法的基本思想：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;初始化：\(\phi(\cdot, 0)\)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;合理假设：\(\frac{\partial \vec{x}}{\partial t}\)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;随着时间跟随：\(\phi(\cdot, t)\)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用数值积分实现，例如欧拉逼近（棘手！）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;与轮廓正交的演化&lt;/strong&gt;：&lt;/p&gt;

\[\begin{aligned} \frac{\partial \vec{x}}{\partial t} &amp;amp;=\alpha \cdot \frac{\nabla \phi}{\|\nabla \phi\|} \\ \frac{\partial \phi}{\partial t} &amp;amp;=-\nabla \phi \cdot \alpha \cdot \frac{\nabla \phi}{\|\nabla \phi\|} \\ &amp;amp;=-\alpha \frac{\|\nabla \phi\|^{2}}{\|\nabla \phi\|}=-\alpha\|\nabla \phi\| \end{aligned}\]

&lt;p&gt;如果 α &amp;gt; 0, 轮廓扩张； 如果 α &amp;lt; 0, 轮廓收缩&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308105251.png&quot; alt=&quot;&quot; /&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308105650.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;水平集演化可用于实现形态学运算：&lt;/p&gt;

&lt;p&gt;膨胀 = 扩张&lt;/p&gt;

&lt;p&gt;腐蚀 = 缩小&lt;/p&gt;

&lt;p&gt;闭运算 = 缩小后扩张&lt;/p&gt;

&lt;p&gt;开运算 = 扩张后缩小&lt;/p&gt;

&lt;p&gt;使轮廓更加平滑&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在凹陷的地方扩大&lt;/li&gt;
  &lt;li&gt;在凸面区域缩小&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;i演化水平集&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;正交于轮廓线&lt;/li&gt;
  &lt;li&gt;取决于局部曲率\(\kappa\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在凸区域：局部近似轮廓的圆 \(\kappa = 1/r\)&lt;/p&gt;

&lt;p&gt;在凹面区域：局部近似轮廓的圆\(\kappa = -1/r\)&lt;/p&gt;

&lt;p&gt;一般来说：\(\kappa=\nabla\left(\frac{\nabla \phi}{\|\nabla \phi\|}\right)\)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;level set update:&lt;/strong&gt; 水平集升级：&lt;/p&gt;

&lt;p&gt;\(\frac{\partial \vec{x}}{\partial t}=-\beta \kappa \frac{\nabla \phi}{\|\nabla \phi\|}\)
\(\frac{\partial \phi}{\partial t}=\beta \kappa\|\nabla \phi\|\)&lt;/p&gt;

&lt;p&gt;对黑白图非常简单的想法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从一个非常大的轮廓线开始&lt;/li&gt;
  &lt;li&gt;在白色像素处缩减轮廓线&lt;/li&gt;
  &lt;li&gt;不要在黑色像素处收缩&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;轮廓包围黑色区域：&lt;/p&gt;

\[\frac{\partial \vec{x}}{\partial t}= \begin{cases}-\gamma \cdot \frac{\nabla \phi}{\|\nabla \phi\|} &amp;amp; \text { if white pixel } \\ 0 &amp;amp; \text { if black pixel }\end{cases}\]

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308102404.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;将分割与轮廓矫正相结合&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308152349.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;基于梯度的图像分割方法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从一个非常大的轮廓线开始&lt;/li&gt;
  &lt;li&gt;在梯度长度小的像素处缩小轮廓&lt;/li&gt;
  &lt;li&gt;在梯度长度大的像素处不收缩（边缘像素）。
→ 等高线包裹边缘的区域&lt;/li&gt;
&lt;/ul&gt;

\[\frac{\partial \vec{x}}{\partial t}=-\epsilon(g) \cdot \frac{\nabla \phi}{\|\nabla \phi\|}\]

\[\epsilon(g)=\frac{\gamma}{\gamma+\mid \text { Gauss }\left.* \nabla g\right|^{p}}\]

&lt;p&gt;with appropriate \(\gamma&amp;gt;0, p \geq 1\) \(g\)denotes gray level image&lt;/p&gt;

&lt;h2 id=&quot;基于-mumford-shah-的分割&quot;&gt;基于 Mumford-Shah 的分割&lt;/h2&gt;

&lt;p&gt;理念：像素应被分配到具有最相似分割的灰度值（颜色值）。&lt;/p&gt;

&lt;p&gt;\(\bar{g}_{\text {foreground }}\)：前景段像素的平均灰度值（颜色）&lt;/p&gt;

&lt;p&gt;\(\bar{g}_{\text {background }}\):背景段中像素的平均灰度值（颜色）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308152913.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用灰色（颜色）值检查边界上的像素 &lt;em&gt;Ⅰ&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;像素更类似于外部区域
 缩小轮廓&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;像素更类似于外部区域：&lt;/p&gt;

\[\left(g-\bar{g}_{\text {foreground }}\right)^{2}&amp;lt;\left(g-\bar{g}_{\text {background }}\right)^{2}\]

    &lt;p&gt;扩张轮廓&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;基于 Mumford-Shah 的分割：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308154055.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;随机场&quot;&gt;随机场&lt;/h1&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;每个像素属于一个分割。 但是哪一个？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308160246.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;每个像素的分段标签被看作是一个变量
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;strong&gt;像素的特征向量&lt;/strong&gt;与其&lt;strong&gt;标签&lt;/strong&gt;有关&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308161049.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;像素的特征向量也被视为变量，然而，它的值是被观察到的&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

\[\phi_{f}(l(u, v), f(u, v)) \begin{cases}\text { is small } &amp;amp; \text { if } f(u, v) \text { supports label } l(u, v) \\ \text { is large } &amp;amp; \text { if } f(u, v) \text { does not support label } l(u, v)\end{cases}\]

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308155748.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;相邻像素的标签也相关&lt;/p&gt;

&lt;p&gt;\(l(u, v) \leftrightarrow l(u+1, v)\)
\(l(u, v) \leftrightarrow l(u, v+1)\)&lt;/p&gt;

&lt;p&gt;该关系再次由势函数建模&lt;/p&gt;

&lt;p&gt;\(\phi_{n}(l(u, v), l(u+1, v))\)
\(\phi_{n}(l(u, v), l(u, v+1))\)&lt;/p&gt;

\[\phi_{n}(l(u, v), l(u+1, v))\left\{\begin{array}{l}\text { is small } \\ \text { if } l(u, v) \text { and } l(u+1, v) \text { are similar } \\ \text { is large } \\ \text { if } l(u, v) \text { and } l(u+1, v) \text { are dissimilar }\end{array}\right.\]

&lt;p&gt;找到标签 l(u,v) 使得势函数最小化&lt;/p&gt;

\[\begin{aligned} \operatorname{minimize}_{l(\cdot, \cdot)} &amp;amp; \alpha_{f} \cdot \sum_{u, v} \phi_{f}(l(u, v), f(u, v)) \\ &amp;amp;+\alpha_{n} \cdot \sum_{u, v} \phi_{n}(l(u, v), l(u+1, v)) \\ &amp;amp;+\alpha_{n} \cdot \sum_{u, v} \phi_{n}(l(u, v), l(u, v+1)) \end{aligned}\]

&lt;p&gt;带权重因子\(\alpha_{f}, \alpha_{n}&amp;gt;0\)&lt;/p&gt;

&lt;p&gt;优化问题的解决方案： 精确 → 困难（一般来说，存在例外）；近似&lt;/p&gt;

&lt;p&gt;例如：从深色背景中提取明亮的前景对象&lt;/p&gt;

&lt;p&gt;\(l=0 \quad\) background
\(l=1 \quad\) foreground
\(f \quad\) gray value \(0 \leq f \leq 255\)&lt;/p&gt;

\[\begin{aligned}
&amp;amp;\phi_{f}(l, f)=\left(l-\frac{1}{255} f\right)^{2} \\
&amp;amp;\phi_{n}\left(l, l^{\prime}\right)=\left(l-l^{\prime}\right)^{2}
\end{aligned}\]

&lt;p&gt;实现分割标准。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;预定的颜色标准&lt;/li&gt;
  &lt;li&gt;空间标准&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308164349.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;随机场建模的优势。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;分割问题被表述为优化问题&lt;/li&gt;
  &lt;li&gt;潜在函数允许对许多分割标准进行建模，例如
    &lt;ul&gt;
      &lt;li&gt;种子点
对种子点保持标签函数不变&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;对某些分段标签的一般偏好（先验的）。
→ 增加单项潜力函数
例如，指定前景物体应在图像的中心位置&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308164451.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原型分割特征向量。像素应该被分配到具有最相似原型特征向量的分割。
原型特征最相似的分割。
→ 将原型变量添加到随机域中，每分割一个。
→ 添加势函数，对原型特征和像素特征的相似性进行建模 f&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308164649.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;–&amp;gt;应用同质性标准&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;假设前景和背景的划分是
    &lt;ul&gt;
      &lt;li&gt;前景物体位于图像的中心位置&lt;/li&gt;
      &lt;li&gt;前景物体和背景物体具有独特的颜色&lt;/li&gt;
      &lt;li&gt;使用像素颜色（例如在RGB中）作为特征&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

\[\phi_{\text {prior }}(l(u, v))= \begin{cases}\max \left\{\frac{\mid 2 u-\text { width } \mid}{\text { width }}, \frac{|2 v-h e i g h t|}{h e i g h t}\right\} &amp;amp; \text { if } l(u, v)=1 \\ 1-\max \left\{\frac{\mid 2 u-\text { width } \mid}{\text { width }}, \frac{\mid 2 v-h e i g h t}{\text { height }}\right\} &amp;amp; \text { if } l(u, v)=0\end{cases}\]

\[\phi_{\text {prototype }}(l, f, p)=\|f-p(l)\|^{2}\]

\[\phi_{n}\left(l, l^{\prime}\right)=\left(l-l^{\prime}\right)^{2}\]

&lt;p&gt;\(\phi_{\text {prior }}(l(u, v))= \begin{cases}\max \left\{\frac{\mid 2 u-\text { width } \mid}{\text { width }}, \frac{\mid 2 v-\text { height } \mid}{\text { height }}\right\} &amp;amp; \text { if } l(u, v)=1 \\ 1-\max \left\{\frac{\mid 2 u-\text { width } \mid}{\text { width }}, \frac{|2 v-h e i g h t|}{\text { height }}\right\} &amp;amp; \text { if } l(u, v)=0\end{cases}$
$\phi_{\text {prototype }}(l, f, p)=\|f-p(l)\|^{2}\)
\(\phi_{n}\left(l, l^{\prime}\right)=\left(l-l^{\prime}\right)^{2}\)&lt;/p&gt;

\[\begin{aligned} \operatorname{minimize}_{l(\cdot, \cdot), p(\cdot)} &amp;amp; \alpha_{\text {prior }} \cdot \sum_{u, v} \phi_{\text {prior }}(l(u, v)) \\ &amp;amp;+\alpha_{f} \cdot \sum_{u, v} \phi_{\text {prototype }}(l(u, v), f(u, v), p) \\ &amp;amp;+\alpha_{n} \cdot \sum_{u, v} \phi_{n}(l(u, v), l(u+1, v)) \\ &amp;amp;+\alpha_{n} \cdot \sum_{u, v} \phi_{n}(l(u, v), l(u, v+1)) \end{aligned}\]

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220308164951.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 08 Mar 2022 00:00:00 +0800</pubDate>
        <link>https://wenboli-cn-de.github.io/2022/03/MV6.1/</link>
        <guid isPermaLink="true">https://wenboli-cn-de.github.io/2022/03/MV6.1/</guid>
        
        <category>专业</category>
        
        <category>机器视觉</category>
        
        
      </item>
    
      <item>
        <title>机器视觉-图像分割(第一部分) Segmentation</title>
        <description>&lt;head&gt;
    &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    &lt;/script&gt;
&lt;/head&gt;
&lt;h1 id=&quot;机器视觉-图像分割第一部分&quot;&gt;机器视觉-图像分割(第一部分)&lt;/h1&gt;

&lt;p&gt;在计算机视觉领域， &lt;strong&gt;图像分割&lt;/strong&gt; （segmentation）指的是将数字图像细分为多个图像子区域（像素的集合）（也被称作超像素）的过程。图像分割的目的是&lt;strong&gt;简化或改变图像的表示形式&lt;/strong&gt;，使得图像更容易理解和分析。图像分割通常用于定位图像中的物体和边界（线，曲线等）。更精确的，图像分割是对图像中的每个像素加标签的一个过程，&lt;strong&gt;这一过程使得具有相同标签的像素具有某种共同视觉特性&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;图像分割在&lt;strong&gt;实际中的应用&lt;/strong&gt;：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在卫星图像中定位物体（道路、森林等）

人脸识别

指纹识别

交通控制系统

刹车灯检测 Brake light detection
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;分割的准则&quot;&gt;分割的准则&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;预定义的颜色标准 predefined color criterion&lt;/li&gt;
  &lt;li&gt;邻域准则 neighborhood criterion&lt;/li&gt;
  &lt;li&gt;均匀性准则 homogeneity criterion&lt;/li&gt;
  &lt;li&gt;连通性准则 connectedness criterion&lt;/li&gt;
  &lt;li&gt;空间准则 spatial criterion&lt;/li&gt;
  &lt;li&gt;边界光滑准则 boundary smoothness criterion&lt;/li&gt;
  &lt;li&gt;尺寸准则 size criteria&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302202410.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;预定义的颜色标准-predefined-color-criterion&quot;&gt;预定义的颜色标准 predefined color criterion&lt;/h2&gt;

&lt;p&gt;像素颜色属于一组预定义的”有趣”的颜色，它指定了哪些颜色值是相关的，哪些像素是彩色的。&lt;/p&gt;

&lt;p&gt;例如，我们在下面的足球机器人场地上找到橙色的球。&lt;/p&gt;

&lt;p&gt;橙色的像素点是在HSV值在以下范围的：&lt;/p&gt;

&lt;p&gt;$0^{\circ} \leq H \leq 24^{\circ}, 0.4 \leq S \leq 1,0.4 \leq V \leq 1$&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302193913.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302194516.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注： HSV值(Hue, Saturation, Value)是是根据颜色的直观特性由A. R. Smith在1978年创建的一种颜色空间, 也称六角锥体模型(Hexcone Model)。这个模型中颜色的参数分别是：色调（H），饱和度（S），亮度（V）。&lt;/p&gt;

&lt;p&gt;色调H：用角度度量，取值范围为0°～360°，从红色开始按逆时针方向计算，红色为0°，绿色为120°,蓝色为240°。它们的补色是：黄色为60°，青色为180°,品红为300°；&lt;/p&gt;

&lt;p&gt;饱和度S：取值范围为0.0～1.0；&lt;/p&gt;

&lt;p&gt;亮度V：取值范围为0.0(黑色)～1.0(白色)。&lt;/p&gt;

&lt;p&gt;RGB和CMY颜色模型都是面向硬件的，而HSV（Hue Saturation Value）颜色模型是面向用户的。&lt;/p&gt;

&lt;p&gt;HSV模型的三维表示从RGB立方体演化而来。设想从RGB沿立方体对角线的白色顶点向黑色顶点观察，就可以看到立方体的六边形外形。六边形边界表示色彩，水平轴表示纯度，明度沿垂直轴测量。&lt;/p&gt;

&lt;p&gt;根据颜色进行分割的优缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;非常快速&lt;/li&gt;
  &lt;li&gt;如果事先知道物体的颜色，并且颜色具有辨别力，则&lt;strong&gt;可以应用&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;如果不同的对象共享相同的颜色，则&lt;strong&gt;不适用&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;找到合适的颜色规格通常很麻烦&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;邻域准则-neighborhood-criterion&quot;&gt;邻域准则 neighborhood criterion&lt;/h2&gt;

&lt;p&gt;像素颜色与相邻像素的颜色相似，指定哪些颜色相似，将一段中的所有像素分组，这些像素至少有一个已属于该段的相邻像素&lt;/p&gt;

&lt;p&gt;例如：如果RGB三元组的欧氏距离小于7/255，则像素是相邻的&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302193913.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302195234.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;根据邻域准则进行图片细分的优缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;简单&lt;/li&gt;
  &lt;li&gt;物体的颜色不需要知道&lt;/li&gt;
  &lt;li&gt;对象边界必须是高对比度，内部必须是低对比度&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;模糊的图像可能导致分段不足，嘈杂的图像可能导致分段过度&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;均匀性准则-homogeneity-criterion&quot;&gt;均匀性准则 homogeneity criterion&lt;/h2&gt;

&lt;p&gt;像素颜色与线段的分割颜色相似，指定如何计算平均的颜色并确定两种颜色是否相似。将所有像素分组到一段中，这些像素与分割的平均颜色相似&lt;/p&gt;

&lt;p&gt;例如：与球的平均颜色相似的像素，都属于此分割颜色&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302193913.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302195909.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过均匀性准测进行图像分割的优缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;物体的颜色不需要知道&lt;/li&gt;
  &lt;li&gt;对象的所有部分都必须具有相似的颜色&lt;/li&gt;
  &lt;li&gt;不支持低频率的颜色变化&lt;/li&gt;
  &lt;li&gt;循环定义&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;连通性准则-connectedness-criterion&quot;&gt;连通性准则 connectedness criterion&lt;/h2&gt;

&lt;p&gt;同一段中的所有像素必须连接，即在该段的两个像素之间有一条不离开该段的路径&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302200517.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;优缺点：&lt;/p&gt;

&lt;p&gt;此标准可以与其他标准相结合&lt;/p&gt;

&lt;h2 id=&quot;空间准则-spatial-criterion&quot;&gt;空间准则 spatial criterion&lt;/h2&gt;

&lt;p&gt;被另一部分的像素包围的像素应该属于该部分（另一部分）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302201711.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;优缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;标准与其他标准相结合&lt;/li&gt;
  &lt;li&gt;提高了抗噪性&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;边界光滑准则-boundary-smoothness-criterion&quot;&gt;边界光滑准则 boundary smoothness criterion&lt;/h2&gt;

&lt;p&gt;分割的边界应平滑，而不是参差不齐。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302201944.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302202044.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;优缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;标准与其他标准相结合&lt;/li&gt;
  &lt;li&gt;提高了抗噪性&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;尺寸准则-size-criteria&quot;&gt;尺寸准则 size criteria&lt;/h2&gt;

&lt;p&gt;分割的大小应在一定范围内/不太小/不太大&lt;/p&gt;

&lt;h1 id=&quot;分割算法&quot;&gt;分割算法&lt;/h1&gt;

&lt;p&gt;基础算法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;区域增长 region growing&lt;/li&gt;
  &lt;li&gt;连接组件标记 connected components labeling&lt;/li&gt;
  &lt;li&gt;K-means和mean-shift算法&lt;/li&gt;
  &lt;li&gt;形态学运算 morphological operations&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;更详尽的算法：&lt;/p&gt;

&lt;p&gt;1.&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%B0%B4%E5%B9%B3%E9%9B%86%E6%96%B9%E6%B3%95&quot;&gt;水平集方法&lt;/a&gt;
     level set methods&lt;/p&gt;

&lt;p&gt;2.&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E5%9C%BA&quot;&gt;随机场&lt;/a&gt; 
    random fields&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302202529.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;区域增长-region-growing&quot;&gt;区域增长 region growing&lt;/h2&gt;

&lt;p&gt;区域生长（region growing）是指将成组的像素或区域发展成更大区域的过程。从种子点的集合开始，从这些点的区域增长是通过将与每个种子点有相似属性像强度、灰度级、纹理颜色等的相邻像素合并到此区域。&lt;/p&gt;

&lt;p&gt;核心思想：从一个/多个种子点开始（必须提供种子点）；增量扩展段，直到无法添加更多像素；实现连通性标准+同质性或邻域标准；产生单一的片段。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302203819.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;优缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;易于实现（广度优先搜索）&lt;/li&gt;
  &lt;li&gt;需要一个或多个种子点&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;连接组件标记算法-connected-components-labelingccl&quot;&gt;连接组件标记算法 connected components labeling（CCL）&lt;/h2&gt;

&lt;p&gt;连接组件标记算法(connected component labeling algorithm)是图像分析中最常用的算法之一，算法的实质是扫描一幅图像的每个像素，对于像素值相同的分为相同的组(group),最终得到图像中所有的像素连通组件。
扫描的方式可以是从上到下，从左到右，对于一幅有N个像素的图像来说，最大连通组件个数为N/2。扫描是基于每个像素单位，对于二值图像而言，连通组件集合可以是V={1|白色}或者V={0|黑色}, 取决于前景色与背景色的不同。
对于灰度图像来说，连图组件像素集合可能是一系列在0 ～ 255之间k的灰度值。&lt;/p&gt;

&lt;p&gt;引用自：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/81959284&quot;&gt;知乎&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;核心思想：创建图像的完整分割；实现连通性标准+邻域标准；仅通过确定与两个相邻像素的相似性，将每个像素分配给分段&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302205133.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们从左上角到右下角逐行访问像素，并立即将它们分配给一个段。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302205336.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当我们访问一个像素（u，v）时，我们已经访问了（u-1，v）和（u，v-1）。&lt;strong&gt;我们比较颜色（u，v）和颜色（u-1，v），颜色（u，v-1），五种情况：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;（u，v）和（u-1，v）处的像素颜色相似，（u，v）和（u，v-1）处的像素颜色不同&lt;/p&gt;

    &lt;p&gt;→ 像素（u，v）和（u-1，v）属于同一段&lt;/p&gt;

    &lt;p&gt;→ 我们将像素（u，v）分配给像素（u-1，v）的部分&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302205643.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;（u，v）和（u-1，v）处的像素颜色不同，（u，v）和（u，v-1）处的像素颜色相似&lt;/p&gt;

    &lt;p&gt;→ 像素（u，v）和（u，v-1）属于同一段&lt;/p&gt;

    &lt;p&gt;→ 我们将像素（u，v）分配给像素（u，v-1）的部分&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302205709.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;（u，v）和（u-1，v）处的像素颜色不同，（u，v）和（u，v-1）处的像素颜色不同&lt;/p&gt;

    &lt;p&gt;→ 为什么像素（u，v）应该属于（u-1，v）或（u，v-1）的段？&lt;/p&gt;

    &lt;p&gt;→ 我们创建一个新段，并为其指定像素（u，v）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302210249.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;（u，v）和（u-1，v）处的像素颜色是相似的，（u，v）和（u，v-1）处的像素颜色是相似的，像素（u-1，v）和（u，v-1）属于同一段。&lt;/p&gt;

    &lt;p&gt;→ 像素（u，v）也属于该部分&lt;/p&gt;

    &lt;p&gt;→ 我们将像素（u，v）分配给该段&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302210306.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;（u，v）和（u-1，v）处的像素颜色相似，（u，v）和（u，v-1）处的像素颜色相似，像素（u-1，v）和（u，v-1）不属于同一段&lt;/p&gt;

    &lt;p&gt;→ 像素（u，v）属于两个相邻的部分&lt;/p&gt;

    &lt;p&gt;→ 我们合并两个相邻的段，并将像素（u，v）分配给合并的段&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302210325.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302210354.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;k均值聚类算法-k-means&quot;&gt;K均值聚类算法 K-means&lt;/h2&gt;

&lt;p&gt;k均值聚类算法（k-means clustering algorithm）是一种迭代求解的聚类分析算法，其步骤是，预将数据分为K组，则随机选取K个对象作为初始的聚类中心，然后计算每个对象与各个种子聚类中心之间的距离，把每个对象分配给距离它最近的聚类中心。聚类中心以及分配给它们的对象就代表一个聚类。每分配一个样本，聚类的聚类中心会根据聚类中现有的对象被重新计算。这个过程将不断重复直到满足某个终止条件。终止条件可以是没有（或最小数目）对象被重新分配给不同的聚类，没有（或最小数目）聚类中心再发生变化，误差平方和局部最小。&lt;/p&gt;

&lt;p&gt;核心思想：图像由相似颜色的区域组成; 寻找颜色的簇; 将每个像素指定给其颜色簇; 实现同质性标准; 创建完整的分割。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302193913.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在上面图片中的颜色簇：绿色，白色，橙色，黑色，品红，蓝，黄色，灰色&lt;/p&gt;

&lt;p&gt;怎么找到颜色簇呢？ 如果我们知道簇的数量 –&amp;gt; k-means 算法&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;随机初始化k原型颜色c1、c2、…、ck（例如，从图像中随机选取像素）&lt;/li&gt;
  &lt;li&gt;将每个像素指定给最相似的原型颜色&lt;/li&gt;
  &lt;li&gt;通过对步骤2中指定的像素颜色进行平均，重新计算原型颜色&lt;/li&gt;
  &lt;li&gt;重复第2步和第3步，直到收敛（即第2步中的赋值不再改变）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302211110.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第1步：从两个像素中随机选择颜色；&lt;/p&gt;

&lt;p&gt;第2步：将像素分配给最相似的簇；&lt;/p&gt;

&lt;p&gt;第3步：重新计算原型颜色；&lt;/p&gt;

&lt;p&gt;第2步：重新分配像素；&lt;/p&gt;

&lt;p&gt;第3步：重新计算原型颜色；&lt;/p&gt;

&lt;p&gt;第2步：重新分配像素→ 汇聚&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302211413.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302211438.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302211525.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302211638.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;k-均值算法&lt;/p&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;p&gt;•简单、易于实现&lt;/p&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;p&gt;•必须知道聚类数（k）&lt;/p&gt;

&lt;p&gt;•通常会收敛到次优聚类（取决于初始原型颜色）&lt;/p&gt;

&lt;p&gt;未知聚类数的改进： &lt;strong&gt;mean-shift&lt;/strong&gt; 均值漂移&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;需要颜色的相似性度量&lt;/li&gt;
  &lt;li&gt;对于每个像素p，按如下步骤进行：
1.确定p的颜色并将其分配给变量c
    &lt;ol&gt;
      &lt;li&gt;找到图像中与c相似的所有像素的集合S&lt;/li&gt;
      &lt;li&gt;计算S的平均颜色并将其分配给变量c（不要改变图像中p的像素值
不要改变图像中p的像素值！)&lt;/li&gt;
      &lt;li&gt;重复步骤2和3，直到收敛（即直到步骤2中的S保持不变）。&lt;/li&gt;
      &lt;li&gt;最后，c是像素p所属区段的原型颜色。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例: 沿一个轴排列所有像素颜色（灰度值）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302212227.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第1步：选择目标像素的颜色并初始化c
第2步：找到相似像素的集合S
第3步：计算S的平均颜色并将其分配给c
第2步：重新计算S
第3步：重新计算S的平均颜色并将其分配给c
第2步：重新计算S
第3步：重新计算S的平均颜色并将其分配给c
第2步：重新计算S→收敛&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220302212319.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 02 Mar 2022 00:00:00 +0800</pubDate>
        <link>https://wenboli-cn-de.github.io/2022/03/MV6/</link>
        <guid isPermaLink="true">https://wenboli-cn-de.github.io/2022/03/MV6/</guid>
        
        <category>专业</category>
        
        <category>机器视觉</category>
        
        
      </item>
    
      <item>
        <title>机器视觉-曲线拟合(圆和椭圆) Curve Fitting</title>
        <description>&lt;head&gt;
    &lt;script type=&quot;text/javascript&quot; async=&quot;&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;
   &lt;/script&gt;
&lt;/head&gt;

&lt;h1 id=&quot;曲线拟合圆和椭圆&quot;&gt;曲线拟合——圆和椭圆&lt;/h1&gt;

&lt;p&gt;在上一篇文章中，我们总结了视觉识别中对于直线型边缘的拟合。但是如果有的图形边缘是曲线的话应该怎么拟合？ 这一篇博文，我们就对其进行讨论。&lt;/p&gt;

&lt;h2 id=&quot;标准圆&quot;&gt;标准圆&lt;/h2&gt;

&lt;p&gt;首先圆的方程为：\(\left(x-m_{1}\right)^{2}+\left(y-m_{2}\right)^{2}-r^{2} = 0\)&lt;/p&gt;

&lt;p&gt;因为d很小，用趋近的想法来考虑&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220130112538.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那么点(x,y)到圆的欧几里得距离大小为：&lt;/p&gt;

\[d_{E}=\left|\sqrt{\left(x-m_{1}\right)^{2}+\left(y-m_{2}\right)^{2}}-r\right|\]

&lt;p&gt;代数距离为&lt;/p&gt;

\[d_{A}=\left|\left(x-m_{1}\right)^{2}+\left(y-m_{2}\right)^{2}-r^{2}\right|\]

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220130113813.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220130113853.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;根据图知道，欧几里得距离和代数距离是不对称的，靠近圆的点都是相似的。&lt;/p&gt;

&lt;p&gt;两种思路：最小化欧几里得距离和最小化代数距离。解析法&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;最小化欧几里得距离
不能用解析法求解，必须数值优化&lt;/p&gt;

    &lt;p&gt;解析法又称为分析法，它是应用解析式去求解数学模型的方法。 数学中用解析式表示函数或任意数学对象的方法叫解析法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最小化代数距离&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;重写代数距离：\(\begin{aligned} \left(x-m_{1}\right)^{2}+\left(y-m_{2}\right)^{2}-r^{2} &amp;amp;=\left(x^{2}+y^{2}\right)+\left(m_{1}^{2}+m_{2}^{2}-r^{2}\right)+\left(-2 m_{1}\right) x+\left(-2 m_{2}\right) y \\ &amp;amp;=A x+B y+C+\left(x^{2}+y^{2}\right) \\ \text { with } &amp;amp; A=-2 m_{1}, B=-2 m_{2}, C=m_{1}^{2}+m_{2}^{2}-r^{2} \end{aligned}\)&lt;/li&gt;
      &lt;li&gt;最小化：\(\sum_{i=1}^{N}\left(A x_{i}+B y_{i}+C+\left(x_{i}^{2}+y_{i}^{2}\right)\right)^{2}\)&lt;/li&gt;
      &lt;li&gt;偏导数归零: \(\left(\begin{array}{ccc} \sum_{i} x_{i}^{2} &amp;amp; \sum_{i} x_{i} y_{i} &amp;amp; \sum_{i} x_{i} \\ \sum_{i} x_{i} y_{i} &amp;amp; \sum_{i} y_{i}^{2} &amp;amp; \sum_{i} y_{i} \\ \sum_{i} x_{i} &amp;amp; \sum_{i} y_{i} &amp;amp; N \end{array}\right)\left(\begin{array}{l} A \\ B \\ C \end{array}\right)=\left(\begin{array}{c} -\sum_{i} x_{i}\left(x_{i}^{2}+y_{i}^{2}\right) \\ -\sum_{i} y_{i}\left(x_{i}^{2}+y_{i}^{2}\right) \\ -\sum_{i}\left(x_{i}^{2}+y_{i}^{2}\right) \end{array}\right)\)&lt;/li&gt;
      &lt;li&gt;最后得到： \(\begin{aligned} m_{1} &amp;amp;=-\frac{A}{2} \\ m_{2} &amp;amp;=-\frac{B}{2} \\ r^{2} &amp;amp;=m_{1}^{2}+m_{2}^{2}-C \end{aligned}\)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;椭圆&quot;&gt;椭圆&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220130115302.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;椭圆特性：&lt;/p&gt;

&lt;p&gt;长短轴：半长轴r1，半短轴r2；&lt;/p&gt;

&lt;p&gt;中心点：m&lt;/p&gt;

&lt;p&gt;旋转角：θ&lt;/p&gt;

&lt;p&gt;代数表达式：\(\begin{array}{l} A x^{2}+H x y+B y^{2}+G x+F y+C=0 \\ \text { with } 4 A B-H^{2}&amp;gt;0 \end{array}\)&lt;/p&gt;

&lt;p&gt;当消除一个自由度时：\(\begin{array}{l} A=1 \\ \text { or } A+B=1 \\ \text { or } A^{2}+B^{2}+C^{2}+F^{2}+G^{2}+H^{2}=1 \\ \text { or } C=1 \text { (not invariant to translation) } \end{array}\)&lt;/p&gt;

&lt;p&gt;根据椭圆的特性，Fitzgibbon, Pilu, 和 Fisher在1999年提出了基于直接最小二乘的椭圆拟合算法，&lt;/p&gt;

&lt;p&gt;最小化了代数距离(通过最小化的约束条件: \(4 A B-H^{2}=1\))&lt;/p&gt;

\[定义：设 A、B 为 n 阶方阵，若存在数λ ，使得方程Ax = λBx 存在 非零解，则称λ 为 A 相对于 B 的广义特征值，x 为 A 相对于 B 的属于 广义特征值λ 的特征向量。\]

\[广义特征值是标准特征值的推广，当B为单位矩阵时，广义标准问题退化为标准特征值问题\]
</description>
        <pubDate>Sun, 30 Jan 2022 00:00:00 +0800</pubDate>
        <link>https://wenboli-cn-de.github.io/2022/01/MV5/</link>
        <guid isPermaLink="true">https://wenboli-cn-de.github.io/2022/01/MV5/</guid>
        
        <category>专业</category>
        
        <category>机器视觉</category>
        
        
      </item>
    
      <item>
        <title>机器视觉-曲线拟合（直线部分） Curve Fitting</title>
        <description>&lt;head&gt;
    &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    &lt;/script&gt;
&lt;/head&gt;

&lt;h1 id=&quot;曲线拟合-curve-fitting&quot;&gt;曲线拟合 Curve Fitting&lt;/h1&gt;

&lt;p&gt;在上一篇文章中，我们讨论了图像的边缘检测，但是边缘检测完毕后存在一个问题就是噪点多，或者换句话说不光滑。&lt;/p&gt;

&lt;p&gt;所以我们再增加一个步骤来使得图像轮廓更加平滑：曲线拟合。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;原始图像–&amp;gt;(通过边缘检测)得到边缘图像–&amp;gt;(通过轮廓探测contour detector)得到坐标值(几何描述)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在进行正式的拟合之前，我们先回顾一下二维几何知识：向量&lt;/p&gt;

&lt;h2 id=&quot;向量&quot;&gt;向量&lt;/h2&gt;

&lt;p&gt;向量知识中有个很重要的概念：点积。&lt;strong&gt;点积的意义主要是表征向量的相似性。值越大代表相似性越好。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220125225003.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;定义：$\langle\vec{p}, \vec{q}\rangle=p_{1} q_{1}+p_{2} q_{2}$  其中p=(p1,p2), q=(q1,q2)&lt;/li&gt;
  &lt;li&gt;双线性：$\langle\alpha \vec{p}+\beta \vec{r}, \gamma \vec{q}+\delta \vec{s}\rangle=\alpha \gamma\langle\vec{p}, \vec{q}\rangle+\alpha \delta\langle\vec{p}, \vec{s}\rangle+\beta \gamma\langle\vec{r}, \vec{q}\rangle+\beta \delta\langle\vec{r}, \vec{s}\rangle$&lt;/li&gt;
  &lt;li&gt;几何定义：$\langle\vec{p}, \vec{q}\rangle=|\vec{p}| \cdot|\vec{q}| \cdot \cos \angle(\vec{p}, \vec{q})$&lt;/li&gt;
  &lt;li&gt;拓展：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;$\langle\vec{p}, \vec{p}\rangle=|\vec{p}|^{2}$， $\langle\vec{p}, \vec{q}\rangle=0 \quad$ if $\vec{p} \perp \vec{q}$&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220125230449.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;线和线段&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们可以把任意向量$\vec{x}$表示为$\vec{p}-\vec{q}$的某一段，我们用$\tau$表示比例，即$\tau(\vec{p}-\vec{q})$, $\tau \in[0,1]$&lt;/p&gt;

&lt;p&gt;那么我们可以得到$\vec{x}=\vec{p}+\tau(\vec{p}-\vec{q})$&lt;/p&gt;

&lt;p&gt;化简得到：&lt;/p&gt;

&lt;p&gt;$\vec{x}=(1-\tau) \vec{p}+\tau \vec{q}, \quad \tau \in[0,1]$&lt;/p&gt;

&lt;p&gt;同理：$\vec{l}$也可通过以上表达：$\vec{l}=(1-\tau) \vec{p}+\tau \vec{q}, \quad \tau \in[0,1]$&lt;/p&gt;

&lt;p&gt;$\vec{l}-\vec{r}=d代表的向量$&lt;/p&gt;

&lt;p&gt;$&amp;lt;\vec{l}-\vec{r},\vec{p}-\vec{q}&amp;gt;=0$     说明d和直线垂直&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;直线的一般形式：&lt;/p&gt;

    &lt;p&gt;$|\vec{n}|=1,\langle\vec{n}, \vec{q}-\vec{p}\rangle=0$ ，$|\vec{n}|为单位向量$&lt;/p&gt;

    &lt;p&gt;$\langle\vec{n}, \vec{x}\rangle=\langle\vec{n},(1-\tau) \vec{p}+\tau \vec{q}\rangle=\langle\vec{n}, \vec{p}\rangle+\tau\langle\vec{n}, \vec{q}-\vec{p}\rangle=\langle\vec{n}, \vec{p}\rangle$&lt;/p&gt;

    &lt;p&gt;$\begin{aligned} 0 &amp;amp;=\langle\vec{n}, \vec{x}\rangle-\langle\vec{n}, \vec{p}\rangle \ &amp;amp;=\langle\vec{n}, \vec{x}\rangle+c \quad \text { (normal form) } \end{aligned}$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;点到直线的距离d：&lt;/p&gt;

\[d=|| \vec{l}-\vec{r} \|=|\langle\vec{n}, \vec{r}\rangle+c|\]
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;用单位向量表示一般向量&quot;&gt;用单位向量表示一般向量：&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220125232803.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;$\vec{v}=\left(\begin{array}{l}v_{1} \ v_{2}\end{array}\right)$&lt;/p&gt;

&lt;p&gt;$\vec{n}=\frac{1}{|\vec{v}|}\left(\begin{array}{c}-v_{2} \ v_{1}\end{array}\right)$&lt;/p&gt;

&lt;p&gt;$\rightarrow \quad|\vec{n}|=1, \vec{n} \perp \vec{v}$&lt;/p&gt;

&lt;p&gt;每个向量都可以用极坐标来表示：&lt;/p&gt;

\[\vec{v}=r \cdot\left(\begin{array}{c}\cos \phi \\ \sin \phi\end{array}\right) \quad，r \geq 0, \phi \in[0,2 \pi)\]

\[\phi=\operatorname{atan}_{2}\left(v_{1}, v_{2}\right)\]

&lt;p&gt;&lt;strong&gt;通过点积可以来判断一个多边形是否面向摄像机（游戏开发中重要的一点）；根据点积来计算光照效果（聚光）；在计算机图学中进行方向性的判断&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;霍夫转换-hough-transform&quot;&gt;霍夫转换 Hough Transform&lt;/h1&gt;

&lt;p&gt;在边缘检测完毕后，我们通过霍夫转换，可以在边缘位图(edge bitmaps)中找到边缘线，每条线可以通过下面的式子来代替：&lt;/p&gt;

&lt;p&gt;$x \cdot \cos \phi+y \cdot \sin \phi+c=0$&lt;/p&gt;

&lt;p&gt;with $0^{\circ} \leq \phi&amp;lt;180^{\circ}$ and $c \in \mathbb{R}$&lt;/p&gt;

&lt;h2 id=&quot;为什么可以这么表示呢&quot;&gt;为什么可以这么表示呢？&lt;/h2&gt;

&lt;p&gt;因为在一般笛卡尔坐标系的直线表达式中，如y = kx+b，存在斜率为无穷大的情况，我们想办法找到一个类似于极坐标的表达方式。通过以上公式表达的方式我们称之为参数空间。在笛卡尔坐标系中的直线表达和 参数空间内的直线表达可以理解为一种映射，可以理解为同一种物体的不同维度的观察。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220125234319.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们知道图中直线和它的垂线(虚线)，一旦直线位置确定，那么其垂线的位置也是确定的。反之亦然。&lt;/p&gt;

&lt;h2 id=&quot;如何找到这种映射关系呢&quot;&gt;如何找到这种映射关系呢？&lt;/h2&gt;

&lt;p&gt;假设有三个点A，B，C我们要判断其是否共线，这里我们假设其共线。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220125202728.png#pic_center&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这条线的方程为&lt;/p&gt;

\[y=-x+2\]

&lt;p&gt;围绕A点可以做无数条直线，B、C同理。那么如果说其中的某三条线重合了，说明ABC共线。&lt;/p&gt;

&lt;p&gt;那么这三条线的极坐标表示也是一样的，在参数空间内就相交于一点。&lt;/p&gt;

&lt;p&gt;那么围绕A点扫描的所有直线的表达式为：&lt;/p&gt;

\[f=0 \times \sin \theta+2 \times \cos \theta, \theta \in[0, \pi]\]

&lt;p&gt;围绕B点扫描的所有直线表达式为：&lt;/p&gt;

\[f=2 \times \sin \theta+0 \times \cos \theta, \theta \in[0, \pi]\]

&lt;p&gt;围绕C点扫描的所有直线表达式为：&lt;/p&gt;

\[f=4 \times \sin \theta-2 \times \cos \theta, \theta \in[0, \pi]\]

&lt;p&gt;然后做出函数图像，我们发现，三个函数交于&lt;/p&gt;

\[\left(\frac{\pi}{4}, \sqrt{2}\right)\]

&lt;p&gt;我们现在知道了，他们相交的直线是以辐角为45°，幅值为$\sqrt{2}$的直线，大家再看笛卡尔坐标系中的直线位置，就明白了其映射关系。大家可以使用其他值作为例子进行体会。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220125202942.png#pic_center&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;霍夫转换的基本步骤&quot;&gt;霍夫转换的基本步骤&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;根据边缘线在参考空间中计算或者画出正弦曲线&lt;/li&gt;
  &lt;li&gt;计算交点&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;值得注意的是，在现实图像处理中，交点并不唯一。（多条线混合在一起）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220126000757.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所以我们只能在&lt;strong&gt;高密度的区域&lt;/strong&gt;中进行找点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用离散累加器单元阵列；&lt;/li&gt;
  &lt;li&gt;对每个单元计算正弦曲线穿过的数量；&lt;/li&gt;
  &lt;li&gt;在累加器阵列中进行局部最大值处理(根据线的参数)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;有点类似我们小时候画三角形的垂直平分线，画完后交不到一点，我们用铅笔继续涂黑。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;在许多边缘上的许多边缘点的霍夫变换&quot;&gt;在许多边缘上的许多边缘点的霍夫变换&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;用0初始化具有足够精度的累加器阵列&lt;/li&gt;
  &lt;li&gt;使得所有满足线方程的累加器单元增加计数（有点拗口，就是计数）&lt;/li&gt;
  &lt;li&gt;在累加器中找到局部最大值（图像中最主要的参数）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在找到线参数后，可以将离线距离小的边缘像素分配到边缘线上。&lt;/p&gt;

&lt;p&gt;但需要做两个工作：1. 确定线的起点和终点。2. 确定允许最大尺寸的间隙。&lt;/p&gt;

&lt;h2 id=&quot;霍夫变换的性质&quot;&gt;霍夫变换的性质&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;结果取决于累积器数组的大小和精度&lt;/li&gt;
  &lt;li&gt;在实践中，确定累积器阵列中的重要峰值可能是困难的&lt;/li&gt;
  &lt;li&gt;梯度方向被忽略&lt;/li&gt;
  &lt;li&gt;累加器数组在”自然场景“中溢出（我猜是计算量过大）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220126002533.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是一张经过霍夫变换后的图，在图中我们可以知道，圆弧部分并没有找到。&lt;/p&gt;

&lt;h1 id=&quot;边缘追踪-edge-following&quot;&gt;边缘追踪 Edge following&lt;/h1&gt;

&lt;p&gt;鉴于霍夫变换的缺点，我们可以通过另一条路线：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;边缘检测edge detection–&amp;gt;边缘追踪edge following–&amp;gt;线段分割polyline segmentation–&amp;gt;直线拟合 line fitting&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;边缘追踪大体思路&quot;&gt;边缘追踪大体思路&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;边缘检测器产生具有边缘像素的位图&lt;/li&gt;
  &lt;li&gt;收集所有边缘像素并按拓扑顺序链接它们&lt;/li&gt;
  &lt;li&gt;使用梯度信息（如果可用）进行链接&lt;/li&gt;
  &lt;li&gt;结果：描述轮廓线的边缘像素列表&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220126003244.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;直线分割-polyline-segmentation&quot;&gt;直线分割 Polyline Segmentation&lt;/h1&gt;

&lt;p&gt;边缘跟踪产生了有序的像素列表，但这些像素列表并不会主动或者自动的生成连线用以表示轮廓，所以我们的任务就是：细分像列表，使子列表可以用线段表示。&lt;/p&gt;

&lt;p&gt;这里有很多的算法，我们只考虑Ramer Douglas Peucker算法，道格拉斯-普克算法&lt;/p&gt;

&lt;h2 id=&quot;道格拉斯-普克算法的基本思路&quot;&gt;道格拉斯-普克算法的基本思路&lt;/h2&gt;

&lt;p&gt;在最远的顶点进行递归细分折线&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220126003732.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从第一个点到最后一个点连成线&lt;/li&gt;
  &lt;li&gt;计算各像素到线的距离&lt;/li&gt;
  &lt;li&gt;若最大的距离大于容差（自己定义的），则在最远的顶点打破边缘列表，并将算法再次应用到两个子列表（列表被打破成两个）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总体思想就是递归思想。&lt;/p&gt;

&lt;h1 id=&quot;直线拟合&quot;&gt;直线拟合&lt;/h1&gt;

&lt;p&gt;由于折线分割和霍夫转换的结果不一定是最优的，所以我们提出直线拟合的算法。&lt;/p&gt;

&lt;p&gt;很容易想到我们以前中学学过的直线拟合算法：最小二乘法&lt;/p&gt;

&lt;h2 id=&quot;最小二乘法&quot;&gt;最小二乘法&lt;/h2&gt;

&lt;p&gt;在这里我们做一下基本的回顾和加深：&lt;/p&gt;

&lt;p&gt;在前面的二维几何知识回顾里，我们知道了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220126004301.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果给定了我们单位向量$\vec{n}$以及$c$, 我们可以计算$\overrightarrow{x_{i}}$到直线的距离为&lt;/p&gt;

\[d_{i}=\left|\left\langle\vec{n}, \vec{x}_{i}\right\rangle+c\right|\]

&lt;p&gt;我们找到最小的$d_{i}$&lt;/p&gt;

&lt;p&gt;&lt;em&gt;不想看推到过程的可以跳到后面，看结论就行了。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;完全最小二乘法：&lt;/p&gt;

\[\underset{\vec{n}, c}{\operatorname{minimise}} \sum_{i=1}^{N} d_{i}^{2}\]

\[\text { subject to }\langle\vec{n}, \vec{n}\rangle=1\]

&lt;p&gt;拉格朗日算子（自行回顾高等数学）&lt;/p&gt;

\[\mathcal{L}(\vec{n}, c, \lambda)=\sum_{i=1}^{N} d_{i}^{2}-\lambda(\langle\vec{n}, \vec{n}\rangle-1)\]

\[=\sum_{i=1}^{N}\left(\left\langle\vec{n}, \vec{x}_{i}\right\rangle+c\right)^{2}-\lambda(\langle\vec{n}, \vec{n}\rangle-1)\]

&lt;p&gt;对$c$进行归零偏导&lt;/p&gt;

\[\frac{\partial \mathcal{L}}{\partial c}=2 \sum_{i=1}^{N}\left\langle\vec{n}, \vec{x}_{i}\right\rangle+2 N c \stackrel{!}{=} 0\]

\[\rightarrow c=-\frac{1}{N} \sum_{i=1}^{N}\left\langle\vec{n}, \vec{x}_{i}\right\rangle=-\frac{1}{N}\left\langle\vec{n}, \sum_{i=1}^{N} \vec{x}_{i}\right\rangle=-\left\langle\vec{n}, \frac{1}{N} \sum_{i=1}^{N} \vec{x}_{i}\right\rangle\]

&lt;p&gt;对$n_{1}$和$n_{2}$归零偏导&lt;/p&gt;

\[\frac{\partial \mathcal{L}}{\partial n_{1}}=2\left(\sum_{i} x_{i, 1}^{2}\right) n_{1}+2\left(\sum_{i} x_{i, 1} x_{i, 2}\right) n_{2}+2\left(\sum_{i} x_{i, 1}\right) c-2 \lambda n_{1} \stackrel{!}{=} 0\]

\[\frac{\partial \mathcal{L}}{\partial n_{2}}=2\left(\sum_{i} x_{i, 1} x_{i, 2}\right) n_{1}+2\left(\sum_{i} x_{i, 2}^{2}\right) n_{2}+2\left(\sum_{i} x_{i, 2}\right) c-2 \lambda n_{2} \stackrel{!}{=} 0\]

&lt;p&gt;替换：&lt;/p&gt;

\[\underbrace{\left(\sum_{i} x_{i, 1}^{2}-\frac{1}{N}\left(\sum_{i} x_{i, 1}\right)^{2}\right)}_{=: \alpha} n_{1}+\underbrace{\left(\sum_{i} x_{i, 1} x_{i, 2}-\frac{1}{N} \sum_{i} x_{i, 1} \sum_{i} x_{i, 2}\right)}_{=: \beta} n_{2}=\lambda n_{1}\]

\[\underbrace{\left(\sum_{i} x_{i, 1} x_{i, 2}-\frac{1}{N} \sum_{i} x_{i, 1} \sum_{i} x_{i, 2}\right)}_{=\beta} n_{1}+\underbrace{\left(\sum_{i} x_{i, 2}^{2}-\frac{1}{N}\left(\sum_{i} x_{i, 2}\right)^{2}\right) n_{2}=\lambda n_{2}}_{=\gamma}\]

&lt;p&gt;用矩阵形式表示：&lt;/p&gt;

\[\left(\begin{array}{ll}
\alpha &amp;amp; \beta \\
\beta &amp;amp; \gamma
\end{array}\right) \vec{n}=\lambda \vec{n}\]

&lt;p&gt;$\lambda$是特征值，$\vec{n}$是特征向量&lt;/p&gt;

&lt;p&gt;两种结果：&lt;/p&gt;

\[\lambda_{1} \geq \lambda_{2} \geq 0\]

&lt;p&gt;$\lambda_{2}$–&amp;gt;最小距离， $\lambda_{1}$–&amp;gt;最大距离。&lt;/p&gt;

&lt;h2 id=&quot;最小二乘法的步骤&quot;&gt;最小二乘法的步骤&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;从所有的边缘像素中计算：   $\sum_{i} x_{i, 1}, \sum_{i} x_{i, 2}, \sum_{i} x_{i, 1}^{2}, \sum_{i} x_{i, 2}^{2}, \sum_{i} x_{i, 1} x_{i, 2}$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;计算矩阵 $\left(\begin{array}{ll}\alpha &amp;amp; \beta \ \beta &amp;amp; \gamma\end{array}\right)$ 的特征向量和特征值，取较小的特征值&lt;/li&gt;
  &lt;li&gt;根据$\vec{n}$计算$c$&lt;/li&gt;
  &lt;li&gt;如果您对线段感兴趣，请根据投影在线上的边缘像素确定起点和终点。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;直线估计&quot;&gt;直线估计&lt;/h2&gt;

&lt;h3 id=&quot;稳健性&quot;&gt;稳健性&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;稳健性是指在估计过程中，拟合过程中，对模型误差的不敏感性。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在最小二乘法中，如果出现异常值，那么拟合的直线很容易被带偏。&lt;/p&gt;

&lt;p&gt;然而异常值在机器视觉中经常出现。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220126011814.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在有两个思路：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;减少总异常值的影响–&amp;gt; M估计，M Estimator&lt;/li&gt;
  &lt;li&gt;忽略异常值–&amp;gt;RANSAC算法&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;m估计&quot;&gt;M估计&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220126012215.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中$\rho$越小，越靠近直线。&lt;/p&gt;

&lt;h3 id=&quot;ransac随机抽样一致算法&quot;&gt;RANSAC随机抽样一致算法&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;一种通过使用观测到的数据点来估计数学模型参数的迭代方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;random sample consensus&lt;/p&gt;

&lt;p&gt;RANSAC算法是一个学习的技巧，通过使用观测数据的随机样本来估计模型参数。RANSAC使用投票机制来寻找优化的拟合结果。每个数据元被用来投票一或多个模型。投票机制基于两点假设：&lt;/p&gt;

&lt;p&gt;（1）噪音大的特征并不能一直单独为某个模型投票&lt;/p&gt;

&lt;p&gt;（2）有足够多的特征来拟合一个好的模型&lt;/p&gt;

&lt;h4 id=&quot;思路&quot;&gt;思路&lt;/h4&gt;

&lt;p&gt;搜索通过尽可能多点靠近的线&lt;/p&gt;

&lt;h4 id=&quot;算法&quot;&gt;算法&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;随机选择两点&lt;/li&gt;
  &lt;li&gt;拟合&lt;/li&gt;
  &lt;li&gt;检查公差带之外的点数（异常值的数量）&lt;/li&gt;
  &lt;li&gt;用不同的点重复这个过程&lt;/li&gt;
  &lt;li&gt;选择异常值数量最少的线&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Tue, 25 Jan 2022 00:00:00 +0800</pubDate>
        <link>https://wenboli-cn-de.github.io/2022/01/MV4/</link>
        <guid isPermaLink="true">https://wenboli-cn-de.github.io/2022/01/MV4/</guid>
        
        <category>专业</category>
        
        <category>机器视觉</category>
        
        
      </item>
    
      <item>
        <title>机器视觉-边缘检测 Edge Detection</title>
        <description>&lt;head&gt;
    &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    &lt;/script&gt;
&lt;/head&gt;
&lt;h1 id=&quot;边缘检测的意义&quot;&gt;边缘检测的意义&lt;/h1&gt;

&lt;p&gt;边缘检测是为了提取图像中主体的轮廓特征.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/Snipaste_2022-01-19_16-48-09.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;灰度边缘的特性&quot;&gt;灰度边缘的特性&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;在明亮和黑暗交接出有明显的改变(hard changes)&lt;/li&gt;
  &lt;li&gt;通常发生在物体的边缘处&lt;/li&gt;
  &lt;li&gt;发生在阴影和纹理处&lt;/li&gt;
  &lt;li&gt;边缘和亮度没有关系&lt;/li&gt;
  &lt;li&gt;人类的视觉皮层的许多部分都在处理灰度边缘&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;灰度&quot;&gt;灰度：&lt;/h2&gt;

&lt;p&gt;把白色与黑色之间按对数关系分成若干级，成为灰度等级。范围一般从0-255，黑色为0.&lt;/p&gt;

&lt;h1 id=&quot;寻找边缘&quot;&gt;寻找边缘&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;边缘是灰度变化最大的地方（其变化率最大，可以通过导数判断）&lt;/p&gt;

    &lt;p&gt;$g(u+\epsilon)-g(u-\epsilon)$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;寻找区域内的g的导数的最大值&lt;/p&gt;

    &lt;p&gt;$\frac{\partial g}{\partial u}=\lim _{\epsilon \rightarrow 0} \frac{g(u+\epsilon)-g(u)}{\epsilon}=\lim _{\epsilon \rightarrow 0} \frac{g(u+\epsilon)-g(u-\epsilon)}{2 \epsilon}$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过差分逼近函数进行近似（因为图片中为各个像素点，无法取极限，通过像素点之间的距离来代替）&lt;/p&gt;

    &lt;p&gt;$\frac{\partial g}{\partial u} \approx \frac{g(u+1)-g(u-1)}{2}$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;近似导数可以实现为带滤波器掩码的卷积&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220119173327.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;prewitt算子sobel算子&quot;&gt;Prewitt算子，Sobel算子&lt;/h2&gt;

&lt;p&gt;Prewitt算子： 利用像素点上下，左右邻点的灰度差，在边缘处达到极值边缘检测&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220119173746.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Sobel算子：与Prewitt算子相比，Sobel对像素的位置的影响做了加权，可以降低位置的影响&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220119173847.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;边缘方向&quot;&gt;边缘方向&lt;/h2&gt;

&lt;p&gt;边缘方向edge direction：灰度梯度指向最大灰度上升的方向（正交方向没有灰度变化）&lt;/p&gt;

&lt;p&gt;$\operatorname{grad} g=\left(\frac{\partial g}{\partial u}, \frac{\partial g}{\partial v}\right)$， $\operatorname{grad} g \perp\left(-\frac{\partial g}{\partial v}, \frac{\partial g}{\partial u}\right)$&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; /&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220119175209.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;canny边缘检测&quot;&gt;Canny边缘检测&lt;/h2&gt;

&lt;h3 id=&quot;1-高斯滤波&quot;&gt;1. 高斯滤波&lt;/h3&gt;

&lt;p&gt;高斯滤波用于降噪，使图像变得平滑。&lt;/p&gt;

&lt;p&gt;使用方法：用高斯矩阵乘以每个像素点及其邻域取其带权重的平均值作为最后的灰度值。&lt;/p&gt;

&lt;h3 id=&quot;2-使用边缘计算算子&quot;&gt;2. 使用边缘计算算子&lt;/h3&gt;

&lt;p&gt;上文中的Prewitt/Sobol算子&lt;/p&gt;

&lt;h3 id=&quot;3-使用非极大值抑制&quot;&gt;3. 使用非极大值抑制&lt;/h3&gt;

&lt;p&gt;非极大值抑制：搜索局部最大值，来抑制非极大值。例如在目标检测过程中，同一目标可能会出现大量候选框，我们通过非极大值抑制的方法来进行唯一化。&lt;/p&gt;

&lt;h3 id=&quot;4-使用双阈值法上下阈值法&quot;&gt;4. 使用双阈值法（上下阈值法）&lt;/h3&gt;

&lt;p&gt;使用一个阈值来检测边缘的效果不好，&lt;/p&gt;

&lt;p&gt;小阈值：太多噪点，&lt;/p&gt;

&lt;p&gt;大阈值：轮廓线连接不上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220119180210.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;二阶微分算子laplace算子&quot;&gt;二阶微分算子：Laplace算子&lt;/h2&gt;

&lt;p&gt;拉普拉斯算子属于最简单的各项同性二阶微分算子，对于二阶图像：&lt;/p&gt;

&lt;p&gt;$\begin{aligned} \nabla^{2} g=&amp;amp; \frac{\partial^{2} g}{(\partial u)^{2}}+\frac{\partial^{2} g}
{(\partial v)^{2}}\end{aligned}$&lt;/p&gt;

&lt;p&gt;变化率最大处（一阶导数）=二阶导数为0&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220119180804.png&quot; height=&quot;330&quot; /&gt;&lt;/p&gt;

&lt;p&gt;近似为拉普拉斯算子：&lt;/p&gt;

&lt;p&gt;一阶导数:&lt;/p&gt;

&lt;p&gt;$\frac{\partial g}{\partial u}(u, v) \approx g(u+1, v)-g(u, v)$&lt;/p&gt;

&lt;p&gt;二阶导数：&lt;/p&gt;

&lt;p&gt;$\begin{aligned} \frac{\partial^{2} g}{(\partial u)^{2}}(u, v) &amp;amp; \approx \frac{\partial g}{\partial u}(u, v)-\frac{\partial g}{\partial u}(u-1, v) \ &amp;amp; \approx g(u+1, v)-2 g(u, v)+g(u-1, v) \end{aligned}$&lt;/p&gt;

&lt;p&gt;$		\frac{\partial^{2} g}{(\partial v)^{2}}(u, v) \approx g(u, v+1)-2 g(u, v)+g(u, v-1)$&lt;/p&gt;

&lt;p&gt;可以得到：&lt;/p&gt;

&lt;p&gt;$\nabla^{2} g \approx g(u+1, v)+g(u-1, v)+g(u, v+1)+g(u, v-1)-4 g(u, v)$&lt;/p&gt;

&lt;p&gt;通过掩码器实现：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220119181824.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是二阶导数带有很多的噪声，所以我们结合高斯平滑，从而形成高斯拉普拉斯算子&lt;/p&gt;

&lt;h3 id=&quot;laplacian-of-gaussian-log&quot;&gt;Laplacian of Gaussian， LoG&lt;/h3&gt;

&lt;p&gt;$\nabla^{2}(G * g)=\left(\nabla^{2} G\right) * g$ $(G$ Gaussian $)$ $G(u, v)=\frac{1}{2 \pi \sigma^{2}} e^{-\frac{1}{2 \sigma^{2}}\left(u^{2}+v^{2}\right)}$ $\begin{aligned} \frac{\partial G}{\partial u} &amp;amp;=\frac{1}{2 \pi \sigma^{2}}\left(-\frac{1}{2 \sigma^{2}}\right) 2 u e^{-\frac{1}{2 \sigma^{2}}\left(u^{2}+v^{2}\right)} \ &amp;amp;=-\frac{u}{\sigma^{2}} G(u, v) \ \frac{\partial^{2} G}{(\partial u)^{2}} &amp;amp;=-\frac{1}{\sigma^{2}} G(u, v)-\frac{u}{\sigma^{2}}\left(-\frac{u}{\sigma^{2}} G(u, v)\right) \ &amp;amp;=\frac{u^{2}-\sigma^{2}}{\sigma^{4}} G(u, v) \ \nabla^{2} G &amp;amp;=\frac{u^{2}+v^{2}-2 \sigma^{2}}{\sigma^{4}} G(u, v) \end{aligned}$&lt;/p&gt;

&lt;p&gt;通过掩码器实现：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220119182303.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;LoG算法可以近似为DoG算法：&lt;/p&gt;

&lt;p&gt;$D o G(u, v)=G_{\sigma_{1}}(u, v)-G_{\sigma_{2}}(u, v)$&lt;/p&gt;

&lt;p&gt;关于DoG的介绍：&lt;a href=&quot;https://stonema.github.io/2018/04/16/LoG%E7%AE%97%E5%AD%90%E4%B8%8EDoG%E7%AE%97%E5%AD%90/&quot;&gt;https://stonema.github.io/2018/04/16/LoG%E7%AE%97%E5%AD%90%E4%B8%8EDoG%E7%AE%97%E5%AD%90/&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 19 Jan 2022 00:00:00 +0800</pubDate>
        <link>https://wenboli-cn-de.github.io/2022/01/MV3.1/</link>
        <guid isPermaLink="true">https://wenboli-cn-de.github.io/2022/01/MV3.1/</guid>
        
        <category>专业</category>
        
        <category>机器视觉</category>
        
        
      </item>
    
      <item>
        <title>央视五集电视专题片《零容忍》</title>
        <description>&lt;h1 id=&quot;第一集不负14亿&quot;&gt;第一集:《不负14亿》&lt;/h1&gt;

&lt;p&gt;链接：&lt;a href=&quot;https://www.bilibili.com/video/BV1eL4y1476T?p=1&quot;&gt;https://www.bilibili.com/video/BV1eL4y1476T?p=1&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;第二集打虎拍蝇&quot;&gt;第二集:《打虎拍蝇》&lt;/h1&gt;

&lt;p&gt;链接：&lt;a href=&quot;https://www.bilibili.com/video/BV1eL4y1476T?p=2&quot;&gt;https://www.bilibili.com/video/BV1eL4y1476T?p=2&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;第三集惩前毖后&quot;&gt;第三集:《惩前毖后》&lt;/h1&gt;

&lt;p&gt;链接：&lt;a href=&quot;https://www.bilibili.com/video/BV1eL4y1476T?p=3&quot;&gt;https://www.bilibili.com/video/BV1eL4y1476T?p=3&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;第四集系统施治&quot;&gt;第四集:《系统施治》&lt;/h1&gt;

&lt;p&gt;链接：&lt;a href=&quot;https://www.bilibili.com/video/BV1eL4y1476T?p=4&quot;&gt;https://www.bilibili.com/video/BV1eL4y1476T?p=4&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;第五集永远在路上&quot;&gt;第五集:《永远在路上》&lt;/h1&gt;

&lt;p&gt;链接：&lt;a href=&quot;https://www.bilibili.com/video/BV1eL4y1476T?p=5&quot;&gt;https://www.bilibili.com/video/BV1eL4y1476T?p=5&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/6/6d/Flag_of_the_Chinese_Communist_Party.svg/1200px-Flag_of_the_Chinese_Communist_Party.svg.png&quot; alt=&quot;Flag&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 18 Jan 2022 00:00:00 +0800</pubDate>
        <link>https://wenboli-cn-de.github.io/2022/01/Politik/</link>
        <guid isPermaLink="true">https://wenboli-cn-de.github.io/2022/01/Politik/</guid>
        
        <category>党政</category>
        
        
      </item>
    
      <item>
        <title>Win系统与Linux进行文件互传</title>
        <description>&lt;h2 id=&quot;1-使用工具winscp&quot;&gt;1. 使用工具Winscp&lt;/h2&gt;
&lt;p&gt;Win系统与Linux在局域网内进行文件互传可以通过Winscp软件进行。
值得注意的是Linux必须开启了ssh服务 对于树莓派来说，开启ssh是很容易的。
但是我的另一个Linux系统是XUbuntu（可以理解为小体积的Ubuntu，由于搭载系统的硬件是一台08年的破iMac, 
尝试Ubuntu无果后选择了替代系统，所以有些服务并未安装，比如此处的ssh服务。），其中并没有ssh服务，必须自己安装。&lt;/p&gt;
&lt;h2 id=&quot;2可能出现的问题&quot;&gt;2.可能出现的问题&lt;/h2&gt;
&lt;p&gt;连接过程可能会提示：
网络错误，连接被（Linux主机IP）拒绝&lt;/p&gt;

&lt;p&gt;Xubuntu安装ssh服务：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo apt-get install openssh-server&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;验证SSH服务器状态：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo systemctl status ssh&lt;/code&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Jan 2022 00:00:00 +0800</pubDate>
        <link>https://wenboli-cn-de.github.io/2022/01/Test0/</link>
        <guid isPermaLink="true">https://wenboli-cn-de.github.io/2022/01/Test0/</guid>
        
        <category>技术</category>
        
        
      </item>
    
  </channel>
</rss>
