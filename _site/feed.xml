<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>高傲的电工李</title>
    <description>欢迎来到我的个人博客</description>
    <link>https://wenboli-cn-de.github.io/</link>
    <atom:link href="https://wenboli-cn-de.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 26 Jan 2022 23:57:38 +0800</pubDate>
    <lastBuildDate>Wed, 26 Jan 2022 23:57:38 +0800</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>机器视觉-曲线拟合（直线部分） Curve Fitting</title>
        <description>&lt;head&gt;
    &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    &lt;/script&gt;
&lt;/head&gt;

&lt;h1 id=&quot;曲线拟合-curve-fitting&quot;&gt;曲线拟合 Curve Fitting&lt;/h1&gt;

&lt;p&gt;在上一篇文章中，我们讨论了图像的边缘检测，但是边缘检测完毕后存在一个问题就是噪点多，或者换句话说不光滑。&lt;/p&gt;

&lt;p&gt;所以我们再增加一个步骤来使得图像轮廓更加平滑：曲线拟合。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;原始图像–&amp;gt;(通过边缘检测)得到边缘图像–&amp;gt;(通过轮廓探测contour detector)得到坐标值(几何描述)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在进行正式的拟合之前，我们先回顾一下二维几何知识：向量&lt;/p&gt;

&lt;h2 id=&quot;向量&quot;&gt;向量&lt;/h2&gt;

&lt;p&gt;向量知识中有个很重要的概念：点积。&lt;strong&gt;点积的意义主要是表征向量的相似性。值越大代表相似性越好。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220125225003.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;定义：$\langle\vec{p}, \vec{q}\rangle=p_{1} q_{1}+p_{2} q_{2}$  其中p=(p1,p2), q=(q1,q2)&lt;/li&gt;
  &lt;li&gt;双线性：$\langle\alpha \vec{p}+\beta \vec{r}, \gamma \vec{q}+\delta \vec{s}\rangle=\alpha \gamma\langle\vec{p}, \vec{q}\rangle+\alpha \delta\langle\vec{p}, \vec{s}\rangle+\beta \gamma\langle\vec{r}, \vec{q}\rangle+\beta \delta\langle\vec{r}, \vec{s}\rangle$&lt;/li&gt;
  &lt;li&gt;几何定义：$\langle\vec{p}, \vec{q}\rangle=|\vec{p}| \cdot|\vec{q}| \cdot \cos \angle(\vec{p}, \vec{q})$&lt;/li&gt;
  &lt;li&gt;拓展：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;$\langle\vec{p}, \vec{p}\rangle=|\vec{p}|^{2}$， $\langle\vec{p}, \vec{q}\rangle=0 \quad$ if $\vec{p} \perp \vec{q}$&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220125230449.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;线和线段&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们可以把任意向量$\vec{x}$表示为$\vec{p}-\vec{q}$的某一段，我们用$\tau$表示比例，即$\tau(\vec{p}-\vec{q})$, $\tau \in[0,1]$&lt;/p&gt;

&lt;p&gt;那么我们可以得到$\vec{x}=\vec{p}+\tau(\vec{p}-\vec{q})$&lt;/p&gt;

&lt;p&gt;化简得到：&lt;/p&gt;

&lt;p&gt;$\vec{x}=(1-\tau) \vec{p}+\tau \vec{q}, \quad \tau \in[0,1]$&lt;/p&gt;

&lt;p&gt;同理：$\vec{l}$也可通过以上表达：$\vec{l}=(1-\tau) \vec{p}+\tau \vec{q}, \quad \tau \in[0,1]$&lt;/p&gt;

&lt;p&gt;$\vec{l}-\vec{r}=d代表的向量$&lt;/p&gt;

&lt;p&gt;$&amp;lt;\vec{l}-\vec{r},\vec{p}-\vec{q}&amp;gt;=0$     说明d和直线垂直&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;直线的一般形式：&lt;/p&gt;

    &lt;p&gt;$|\vec{n}|=1,\langle\vec{n}, \vec{q}-\vec{p}\rangle=0$ ，$|\vec{n}|为单位向量$&lt;/p&gt;

    &lt;p&gt;$\langle\vec{n}, \vec{x}\rangle=\langle\vec{n},(1-\tau) \vec{p}+\tau \vec{q}\rangle=\langle\vec{n}, \vec{p}\rangle+\tau\langle\vec{n}, \vec{q}-\vec{p}\rangle=\langle\vec{n}, \vec{p}\rangle$&lt;/p&gt;

    &lt;p&gt;$\begin{aligned} 0 &amp;amp;=\langle\vec{n}, \vec{x}\rangle-\langle\vec{n}, \vec{p}\rangle \ &amp;amp;=\langle\vec{n}, \vec{x}\rangle+c \quad \text { (normal form) } \end{aligned}$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;点到直线的距离d：&lt;/p&gt;

\[d=|| \vec{l}-\vec{r} \|=|\langle\vec{n}, \vec{r}\rangle+c|\]
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;用单位向量表示一般向量&quot;&gt;用单位向量表示一般向量：&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220125232803.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;$\vec{v}=\left(\begin{array}{l}v_{1} \ v_{2}\end{array}\right)$&lt;/p&gt;

&lt;p&gt;$\vec{n}=\frac{1}{|\vec{v}|}\left(\begin{array}{c}-v_{2} \ v_{1}\end{array}\right)$&lt;/p&gt;

&lt;p&gt;$\rightarrow \quad|\vec{n}|=1, \vec{n} \perp \vec{v}$&lt;/p&gt;

&lt;p&gt;每个向量都可以用极坐标来表示：&lt;/p&gt;

\[\vec{v}=r \cdot\left(\begin{array}{c}\cos \phi \\ \sin \phi\end{array}\right) \quad，r \geq 0, \phi \in[0,2 \pi)\]

\[\phi=\operatorname{atan}_{2}\left(v_{1}, v_{2}\right)\]

&lt;p&gt;&lt;strong&gt;通过点积可以来判断一个多边形是否面向摄像机（游戏开发中重要的一点）；根据点积来计算光照效果（聚光）；在计算机图学中进行方向性的判断&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;霍夫转换-hough-transform&quot;&gt;霍夫转换 Hough Transform&lt;/h1&gt;

&lt;p&gt;在边缘检测完毕后，我们通过霍夫转换，可以在边缘位图(edge bitmaps)中找到边缘线，每条线可以通过下面的式子来代替：&lt;/p&gt;

&lt;p&gt;$x \cdot \cos \phi+y \cdot \sin \phi+c=0$&lt;/p&gt;

&lt;p&gt;with $0^{\circ} \leq \phi&amp;lt;180^{\circ}$ and $c \in \mathbb{R}$&lt;/p&gt;

&lt;h2 id=&quot;为什么可以这么表示呢&quot;&gt;为什么可以这么表示呢？&lt;/h2&gt;

&lt;p&gt;因为在一般笛卡尔坐标系的直线表达式中，如y = kx+b，存在斜率为无穷大的情况，我们想办法找到一个类似于极坐标的表达方式。通过以上公式表达的方式我们称之为参数空间。在笛卡尔坐标系中的直线表达和 参数空间内的直线表达可以理解为一种映射，可以理解为同一种物体的不同维度的观察。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220125234319.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们知道图中直线和它的垂线(虚线)，一旦直线位置确定，那么其垂线的位置也是确定的。反之亦然。&lt;/p&gt;

&lt;h2 id=&quot;如何找到这种映射关系呢&quot;&gt;如何找到这种映射关系呢？&lt;/h2&gt;

&lt;p&gt;假设有三个点A，B，C我们要判断其是否共线，这里我们假设其共线。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220125202728.png#pic_center&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这条线的方程为&lt;/p&gt;

\[y=-x+2\]

&lt;p&gt;围绕A点可以做无数条直线，B、C同理。那么如果说其中的某三条线重合了，说明ABC共线。&lt;/p&gt;

&lt;p&gt;那么这三条线的极坐标表示也是一样的，在参数空间内就相交于一点。&lt;/p&gt;

&lt;p&gt;那么围绕A点扫描的所有直线的表达式为：&lt;/p&gt;

\[f=0 \times \sin \theta+2 \times \cos \theta, \theta \in[0, \pi]\]

&lt;p&gt;围绕B点扫描的所有直线表达式为：&lt;/p&gt;

\[f=2 \times \sin \theta+0 \times \cos \theta, \theta \in[0, \pi]\]

&lt;p&gt;围绕C点扫描的所有直线表达式为：&lt;/p&gt;

\[f=4 \times \sin \theta-2 \times \cos \theta, \theta \in[0, \pi]\]

&lt;p&gt;然后做出函数图像，我们发现，三个函数交于&lt;/p&gt;

\[\left(\frac{\pi}{4}, \sqrt{2}\right)\]

&lt;p&gt;我们现在知道了，他们相交的直线是以辐角为45°，幅值为$\sqrt{2}$的直线，大家再看笛卡尔坐标系中的直线位置，就明白了其映射关系。大家可以使用其他值作为例子进行体会。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220125202942.png#pic_center&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;霍夫转换的基本步骤&quot;&gt;霍夫转换的基本步骤&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;根据边缘线在参考空间中计算或者画出正弦曲线&lt;/li&gt;
  &lt;li&gt;计算交点&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;值得注意的是，在现实图像处理中，交点并不唯一。（多条线混合在一起）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220126000757.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所以我们只能在&lt;strong&gt;高密度的区域&lt;/strong&gt;中进行找点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用离散累加器单元阵列；&lt;/li&gt;
  &lt;li&gt;对每个单元计算正弦曲线穿过的数量；&lt;/li&gt;
  &lt;li&gt;在累加器阵列中进行局部最大值处理(根据线的参数)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;有点类似我们小时候画三角形的垂直平分线，画完后交不到一点，我们用铅笔继续涂黑。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;在许多边缘上的许多边缘点的霍夫变换&quot;&gt;在许多边缘上的许多边缘点的霍夫变换&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;用0初始化具有足够精度的累加器阵列&lt;/li&gt;
  &lt;li&gt;使得所有满足线方程的累加器单元增加计数（有点拗口，就是计数）&lt;/li&gt;
  &lt;li&gt;在累加器中找到局部最大值（图像中最主要的参数）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在找到线参数后，可以将离线距离小的边缘像素分配到边缘线上。&lt;/p&gt;

&lt;p&gt;但需要做两个工作：1. 确定线的起点和终点。2. 确定允许最大尺寸的间隙。&lt;/p&gt;

&lt;h2 id=&quot;霍夫变换的性质&quot;&gt;霍夫变换的性质&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;结果取决于累积器数组的大小和精度&lt;/li&gt;
  &lt;li&gt;在实践中，确定累积器阵列中的重要峰值可能是困难的&lt;/li&gt;
  &lt;li&gt;梯度方向被忽略&lt;/li&gt;
  &lt;li&gt;累加器数组在”自然场景“中溢出（我猜是计算量过大）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220126002533.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是一张经过霍夫变换后的图，在图中我们可以知道，圆弧部分并没有找到。&lt;/p&gt;

&lt;h1 id=&quot;边缘追踪-edge-following&quot;&gt;边缘追踪 Edge following&lt;/h1&gt;

&lt;p&gt;鉴于霍夫变换的缺点，我们可以通过另一条路线：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;边缘检测edge detection–&amp;gt;边缘追踪edge following–&amp;gt;线段分割polyline segmentation–&amp;gt;直线拟合 line fitting&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;边缘追踪大体思路&quot;&gt;边缘追踪大体思路&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;边缘检测器产生具有边缘像素的位图&lt;/li&gt;
  &lt;li&gt;收集所有边缘像素并按拓扑顺序链接它们&lt;/li&gt;
  &lt;li&gt;使用梯度信息（如果可用）进行链接&lt;/li&gt;
  &lt;li&gt;结果：描述轮廓线的边缘像素列表&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220126003244.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;直线分割-polyline-segmentation&quot;&gt;直线分割 Polyline Segmentation&lt;/h1&gt;

&lt;p&gt;边缘跟踪产生了有序的像素列表，但这些像素列表并不会主动或者自动的生成连线用以表示轮廓，所以我们的任务就是：细分像列表，使子列表可以用线段表示。&lt;/p&gt;

&lt;p&gt;这里有很多的算法，我们只考虑Ramer Douglas Peucker算法，道格拉斯-普克算法&lt;/p&gt;

&lt;h2 id=&quot;道格拉斯-普克算法的基本思路&quot;&gt;道格拉斯-普克算法的基本思路&lt;/h2&gt;

&lt;p&gt;在最远的顶点进行递归细分折线&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220126003732.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从第一个点到最后一个点连成线&lt;/li&gt;
  &lt;li&gt;计算各像素到线的距离&lt;/li&gt;
  &lt;li&gt;若最大的距离大于容差（自己定义的），则在最远的顶点打破边缘列表，并将算法再次应用到两个子列表（列表被打破成两个）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总体思想就是递归思想。&lt;/p&gt;

&lt;h1 id=&quot;直线拟合&quot;&gt;直线拟合&lt;/h1&gt;

&lt;p&gt;由于折线分割和霍夫转换的结果不一定是最优的，所以我们提出直线拟合的算法。&lt;/p&gt;

&lt;p&gt;很容易想到我们以前中学学过的直线拟合算法：最小二乘法&lt;/p&gt;

&lt;h2 id=&quot;最小二乘法&quot;&gt;最小二乘法&lt;/h2&gt;

&lt;p&gt;在这里我们做一下基本的回顾和加深：&lt;/p&gt;

&lt;p&gt;在前面的二维几何知识回顾里，我们知道了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220126004301.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果给定了我们单位向量$\vec{n}$以及$c$, 我们可以计算$\overrightarrow{x_{i}}$到直线的距离为&lt;/p&gt;

\[d_{i}=\left|\left\langle\vec{n}, \vec{x}_{i}\right\rangle+c\right|\]

&lt;p&gt;我们找到最小的$d_{i}$&lt;/p&gt;

&lt;p&gt;&lt;em&gt;不想看推到过程的可以跳到后面，看结论就行了。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;完全最小二乘法：&lt;/p&gt;

\[\underset{\vec{n}, c}{\operatorname{minimise}} \sum_{i=1}^{N} d_{i}^{2}\]

\[\text { subject to }\langle\vec{n}, \vec{n}\rangle=1\]

&lt;p&gt;拉格朗日算子（自行回顾高等数学）&lt;/p&gt;

\[\mathcal{L}(\vec{n}, c, \lambda)=\sum_{i=1}^{N} d_{i}^{2}-\lambda(\langle\vec{n}, \vec{n}\rangle-1)\]

\[=\sum_{i=1}^{N}\left(\left\langle\vec{n}, \vec{x}_{i}\right\rangle+c\right)^{2}-\lambda(\langle\vec{n}, \vec{n}\rangle-1)\]

&lt;p&gt;对$c$进行归零偏导&lt;/p&gt;

\[\frac{\partial \mathcal{L}}{\partial c}=2 \sum_{i=1}^{N}\left\langle\vec{n}, \vec{x}_{i}\right\rangle+2 N c \stackrel{!}{=} 0\]

\[\rightarrow c=-\frac{1}{N} \sum_{i=1}^{N}\left\langle\vec{n}, \vec{x}_{i}\right\rangle=-\frac{1}{N}\left\langle\vec{n}, \sum_{i=1}^{N} \vec{x}_{i}\right\rangle=-\left\langle\vec{n}, \frac{1}{N} \sum_{i=1}^{N} \vec{x}_{i}\right\rangle\]

&lt;p&gt;对$n_{1}$和$n_{2}$归零偏导&lt;/p&gt;

\[\frac{\partial \mathcal{L}}{\partial n_{1}}=2\left(\sum_{i} x_{i, 1}^{2}\right) n_{1}+2\left(\sum_{i} x_{i, 1} x_{i, 2}\right) n_{2}+2\left(\sum_{i} x_{i, 1}\right) c-2 \lambda n_{1} \stackrel{!}{=} 0\]

\[\frac{\partial \mathcal{L}}{\partial n_{2}}=2\left(\sum_{i} x_{i, 1} x_{i, 2}\right) n_{1}+2\left(\sum_{i} x_{i, 2}^{2}\right) n_{2}+2\left(\sum_{i} x_{i, 2}\right) c-2 \lambda n_{2} \stackrel{!}{=} 0\]

&lt;p&gt;替换：&lt;/p&gt;

\[\underbrace{\left(\sum_{i} x_{i, 1}^{2}-\frac{1}{N}\left(\sum_{i} x_{i, 1}\right)^{2}\right)}_{=: \alpha} n_{1}+\underbrace{\left(\sum_{i} x_{i, 1} x_{i, 2}-\frac{1}{N} \sum_{i} x_{i, 1} \sum_{i} x_{i, 2}\right)}_{=: \beta} n_{2}=\lambda n_{1}\]

\[\underbrace{\left(\sum_{i} x_{i, 1} x_{i, 2}-\frac{1}{N} \sum_{i} x_{i, 1} \sum_{i} x_{i, 2}\right)}_{=\beta} n_{1}+\underbrace{\left(\sum_{i} x_{i, 2}^{2}-\frac{1}{N}\left(\sum_{i} x_{i, 2}\right)^{2}\right) n_{2}=\lambda n_{2}}_{=\gamma}\]

&lt;p&gt;用矩阵形式表示：&lt;/p&gt;

\[\left(\begin{array}{ll}
\alpha &amp;amp; \beta \\
\beta &amp;amp; \gamma
\end{array}\right) \vec{n}=\lambda \vec{n}\]

&lt;p&gt;$\lambda$是特征值，$\vec{n}$是特征向量&lt;/p&gt;

&lt;p&gt;两种结果：&lt;/p&gt;

\[\lambda_{1} \geq \lambda_{2} \geq 0\]

&lt;p&gt;$\lambda_{2}$–&amp;gt;最小距离， $\lambda_{1}$–&amp;gt;最大距离。&lt;/p&gt;

&lt;h2 id=&quot;最小二乘法的步骤&quot;&gt;最小二乘法的步骤&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;从所有的边缘像素中计算：   $\sum_{i} x_{i, 1}, \sum_{i} x_{i, 2}, \sum_{i} x_{i, 1}^{2}, \sum_{i} x_{i, 2}^{2}, \sum_{i} x_{i, 1} x_{i, 2}$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;计算矩阵 $\left(\begin{array}{ll}\alpha &amp;amp; \beta \ \beta &amp;amp; \gamma\end{array}\right)$ 的特征向量和特征值，取较小的特征值&lt;/li&gt;
  &lt;li&gt;根据$\vec{n}$计算$c$&lt;/li&gt;
  &lt;li&gt;如果您对线段感兴趣，请根据投影在线上的边缘像素确定起点和终点。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;直线估计&quot;&gt;直线估计&lt;/h2&gt;

&lt;h3 id=&quot;稳健性&quot;&gt;稳健性&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;稳健性是指在估计过程中，拟合过程中，对模型误差的不敏感性。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在最小二乘法中，如果出现异常值，那么拟合的直线很容易被带偏。&lt;/p&gt;

&lt;p&gt;然而异常值在机器视觉中经常出现。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220126011814.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在有两个思路：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;减少总异常值的影响–&amp;gt; M估计，M Estimator&lt;/li&gt;
  &lt;li&gt;忽略异常值–&amp;gt;RANSAC算法&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;m估计&quot;&gt;M估计&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220126012215.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中$\rho$越小，越靠近直线。&lt;/p&gt;

&lt;h3 id=&quot;ransac随机抽样一致算法&quot;&gt;RANSAC随机抽样一致算法&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;一种通过使用观测到的数据点来估计数学模型参数的迭代方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;random sample consensus&lt;/p&gt;

&lt;p&gt;RANSAC算法是一个学习的技巧，通过使用观测数据的随机样本来估计模型参数。RANSAC使用投票机制来寻找优化的拟合结果。每个数据元被用来投票一或多个模型。投票机制基于两点假设：&lt;/p&gt;

&lt;p&gt;（1）噪音大的特征并不能一直单独为某个模型投票&lt;/p&gt;

&lt;p&gt;（2）有足够多的特征来拟合一个好的模型&lt;/p&gt;

&lt;h4 id=&quot;思路&quot;&gt;思路&lt;/h4&gt;

&lt;p&gt;搜索通过尽可能多点靠近的线&lt;/p&gt;

&lt;h4 id=&quot;算法&quot;&gt;算法&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;随机选择两点&lt;/li&gt;
  &lt;li&gt;拟合&lt;/li&gt;
  &lt;li&gt;检查公差带之外的点数（异常值的数量）&lt;/li&gt;
  &lt;li&gt;用不同的点重复这个过程&lt;/li&gt;
  &lt;li&gt;选择异常值数量最少的线&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Tue, 25 Jan 2022 00:00:00 +0800</pubDate>
        <link>https://wenboli-cn-de.github.io/2022/01/MV4/</link>
        <guid isPermaLink="true">https://wenboli-cn-de.github.io/2022/01/MV4/</guid>
        
        <category>专业</category>
        
        <category>机器视觉</category>
        
        
      </item>
    
      <item>
        <title>机器视觉-边缘检测 Edge Detection</title>
        <description>&lt;head&gt;
    &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    &lt;/script&gt;
&lt;/head&gt;
&lt;h1 id=&quot;边缘检测的意义&quot;&gt;边缘检测的意义&lt;/h1&gt;

&lt;p&gt;边缘检测是为了提取图像中主体的轮廓特征.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/Snipaste_2022-01-19_16-48-09.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;灰度边缘的特性&quot;&gt;灰度边缘的特性&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;在明亮和黑暗交接出有明显的改变(hard changes)&lt;/li&gt;
  &lt;li&gt;通常发生在物体的边缘处&lt;/li&gt;
  &lt;li&gt;发生在阴影和纹理处&lt;/li&gt;
  &lt;li&gt;边缘和亮度没有关系&lt;/li&gt;
  &lt;li&gt;人类的视觉皮层的许多部分都在处理灰度边缘&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;灰度&quot;&gt;灰度：&lt;/h2&gt;

&lt;p&gt;把白色与黑色之间按对数关系分成若干级，成为灰度等级。范围一般从0-255，黑色为0.&lt;/p&gt;

&lt;h1 id=&quot;寻找边缘&quot;&gt;寻找边缘&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;边缘是灰度变化最大的地方（其变化率最大，可以通过导数判断）&lt;/p&gt;

    &lt;p&gt;$g(u+\epsilon)-g(u-\epsilon)$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;寻找区域内的g的导数的最大值&lt;/p&gt;

    &lt;p&gt;$\frac{\partial g}{\partial u}=\lim _{\epsilon \rightarrow 0} \frac{g(u+\epsilon)-g(u)}{\epsilon}=\lim _{\epsilon \rightarrow 0} \frac{g(u+\epsilon)-g(u-\epsilon)}{2 \epsilon}$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过差分逼近函数进行近似（因为图片中为各个像素点，无法取极限，通过像素点之间的距离来代替）&lt;/p&gt;

    &lt;p&gt;$\frac{\partial g}{\partial u} \approx \frac{g(u+1)-g(u-1)}{2}$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;近似导数可以实现为带滤波器掩码的卷积&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220119173327.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;prewitt算子sobel算子&quot;&gt;Prewitt算子，Sobel算子&lt;/h2&gt;

&lt;p&gt;Prewitt算子： 利用像素点上下，左右邻点的灰度差，在边缘处达到极值边缘检测&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220119173746.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Sobel算子：与Prewitt算子相比，Sobel对像素的位置的影响做了加权，可以降低位置的影响&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220119173847.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;边缘方向&quot;&gt;边缘方向&lt;/h2&gt;

&lt;p&gt;边缘方向edge direction：灰度梯度指向最大灰度上升的方向（正交方向没有灰度变化）&lt;/p&gt;

&lt;p&gt;$\operatorname{grad} g=\left(\frac{\partial g}{\partial u}, \frac{\partial g}{\partial v}\right)$， $\operatorname{grad} g \perp\left(-\frac{\partial g}{\partial v}, \frac{\partial g}{\partial u}\right)$&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; /&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220119175209.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;canny边缘检测&quot;&gt;Canny边缘检测&lt;/h2&gt;

&lt;h3 id=&quot;1-高斯滤波&quot;&gt;1. 高斯滤波&lt;/h3&gt;

&lt;p&gt;高斯滤波用于降噪，使图像变得平滑。&lt;/p&gt;

&lt;p&gt;使用方法：用高斯矩阵乘以每个像素点及其邻域取其带权重的平均值作为最后的灰度值。&lt;/p&gt;

&lt;h3 id=&quot;2-使用边缘计算算子&quot;&gt;2. 使用边缘计算算子&lt;/h3&gt;

&lt;p&gt;上文中的Prewitt/Sobol算子&lt;/p&gt;

&lt;h3 id=&quot;3-使用非极大值抑制&quot;&gt;3. 使用非极大值抑制&lt;/h3&gt;

&lt;p&gt;非极大值抑制：搜索局部最大值，来抑制非极大值。例如在目标检测过程中，同一目标可能会出现大量候选框，我们通过非极大值抑制的方法来进行唯一化。&lt;/p&gt;

&lt;h3 id=&quot;4-使用双阈值法上下阈值法&quot;&gt;4. 使用双阈值法（上下阈值法）&lt;/h3&gt;

&lt;p&gt;使用一个阈值来检测边缘的效果不好，&lt;/p&gt;

&lt;p&gt;小阈值：太多噪点，&lt;/p&gt;

&lt;p&gt;大阈值：轮廓线连接不上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220119180210.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;二阶微分算子laplace算子&quot;&gt;二阶微分算子：Laplace算子&lt;/h2&gt;

&lt;p&gt;拉普拉斯算子属于最简单的各项同性二阶微分算子，对于二阶图像：&lt;/p&gt;

&lt;p&gt;$\begin{aligned} \nabla^{2} g=&amp;amp; \frac{\partial^{2} g}{(\partial u)^{2}}+\frac{\partial^{2} g}
{(\partial v)^{2}}\end{aligned}$&lt;/p&gt;

&lt;p&gt;变化率最大处（一阶导数）=二阶导数为0&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220119180804.png&quot; height=&quot;330&quot; /&gt;&lt;/p&gt;

&lt;p&gt;近似为拉普拉斯算子：&lt;/p&gt;

&lt;p&gt;一阶导数:&lt;/p&gt;

&lt;p&gt;$\frac{\partial g}{\partial u}(u, v) \approx g(u+1, v)-g(u, v)$&lt;/p&gt;

&lt;p&gt;二阶导数：&lt;/p&gt;

&lt;p&gt;$\begin{aligned} \frac{\partial^{2} g}{(\partial u)^{2}}(u, v) &amp;amp; \approx \frac{\partial g}{\partial u}(u, v)-\frac{\partial g}{\partial u}(u-1, v) \ &amp;amp; \approx g(u+1, v)-2 g(u, v)+g(u-1, v) \end{aligned}$&lt;/p&gt;

&lt;p&gt;$		\frac{\partial^{2} g}{(\partial v)^{2}}(u, v) \approx g(u, v+1)-2 g(u, v)+g(u, v-1)$&lt;/p&gt;

&lt;p&gt;可以得到：&lt;/p&gt;

&lt;p&gt;$\nabla^{2} g \approx g(u+1, v)+g(u-1, v)+g(u, v+1)+g(u, v-1)-4 g(u, v)$&lt;/p&gt;

&lt;p&gt;通过掩码器实现：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220119181824.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是二阶导数带有很多的噪声，所以我们结合高斯平滑，从而形成高斯拉普拉斯算子&lt;/p&gt;

&lt;h3 id=&quot;laplacian-of-gaussian-log&quot;&gt;Laplacian of Gaussian， LoG&lt;/h3&gt;

&lt;p&gt;$\nabla^{2}(G * g)=\left(\nabla^{2} G\right) * g$ $(G$ Gaussian $)$ $G(u, v)=\frac{1}{2 \pi \sigma^{2}} e^{-\frac{1}{2 \sigma^{2}}\left(u^{2}+v^{2}\right)}$ $\begin{aligned} \frac{\partial G}{\partial u} &amp;amp;=\frac{1}{2 \pi \sigma^{2}}\left(-\frac{1}{2 \sigma^{2}}\right) 2 u e^{-\frac{1}{2 \sigma^{2}}\left(u^{2}+v^{2}\right)} \ &amp;amp;=-\frac{u}{\sigma^{2}} G(u, v) \ \frac{\partial^{2} G}{(\partial u)^{2}} &amp;amp;=-\frac{1}{\sigma^{2}} G(u, v)-\frac{u}{\sigma^{2}}\left(-\frac{u}{\sigma^{2}} G(u, v)\right) \ &amp;amp;=\frac{u^{2}-\sigma^{2}}{\sigma^{4}} G(u, v) \ \nabla^{2} G &amp;amp;=\frac{u^{2}+v^{2}-2 \sigma^{2}}{\sigma^{4}} G(u, v) \end{aligned}$&lt;/p&gt;

&lt;p&gt;通过掩码器实现：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WenboLi-CN-DE/Picture/main/20220119182303.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;LoG算法可以近似为DoG算法：&lt;/p&gt;

&lt;p&gt;$D o G(u, v)=G_{\sigma_{1}}(u, v)-G_{\sigma_{2}}(u, v)$&lt;/p&gt;

&lt;p&gt;关于DoG的介绍：&lt;a href=&quot;https://stonema.github.io/2018/04/16/LoG%E7%AE%97%E5%AD%90%E4%B8%8EDoG%E7%AE%97%E5%AD%90/&quot;&gt;https://stonema.github.io/2018/04/16/LoG%E7%AE%97%E5%AD%90%E4%B8%8EDoG%E7%AE%97%E5%AD%90/&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 19 Jan 2022 00:00:00 +0800</pubDate>
        <link>https://wenboli-cn-de.github.io/2022/01/MV3.1/</link>
        <guid isPermaLink="true">https://wenboli-cn-de.github.io/2022/01/MV3.1/</guid>
        
        <category>专业</category>
        
        <category>机器视觉</category>
        
        
      </item>
    
      <item>
        <title>央视五集电视专题片《零容忍》</title>
        <description>&lt;h1 id=&quot;第一集不负14亿&quot;&gt;第一集:《不负14亿》&lt;/h1&gt;

&lt;p&gt;链接：&lt;a href=&quot;https://www.bilibili.com/video/BV1eL4y1476T?p=1&quot;&gt;https://www.bilibili.com/video/BV1eL4y1476T?p=1&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;第二集打虎拍蝇&quot;&gt;第二集:《打虎拍蝇》&lt;/h1&gt;

&lt;p&gt;链接：&lt;a href=&quot;https://www.bilibili.com/video/BV1eL4y1476T?p=2&quot;&gt;https://www.bilibili.com/video/BV1eL4y1476T?p=2&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;第三集惩前毖后&quot;&gt;第三集:《惩前毖后》&lt;/h1&gt;

&lt;p&gt;链接：&lt;a href=&quot;https://www.bilibili.com/video/BV1eL4y1476T?p=3&quot;&gt;https://www.bilibili.com/video/BV1eL4y1476T?p=3&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;第四集系统施治&quot;&gt;第四集:《系统施治》&lt;/h1&gt;

&lt;p&gt;链接：&lt;a href=&quot;https://www.bilibili.com/video/BV1eL4y1476T?p=4&quot;&gt;https://www.bilibili.com/video/BV1eL4y1476T?p=4&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;第五集永远在路上&quot;&gt;第五集:《永远在路上》&lt;/h1&gt;

&lt;p&gt;链接：&lt;a href=&quot;https://www.bilibili.com/video/BV1eL4y1476T?p=5&quot;&gt;https://www.bilibili.com/video/BV1eL4y1476T?p=5&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/6/6d/Flag_of_the_Chinese_Communist_Party.svg/1200px-Flag_of_the_Chinese_Communist_Party.svg.png&quot; alt=&quot;Flag&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 18 Jan 2022 00:00:00 +0800</pubDate>
        <link>https://wenboli-cn-de.github.io/2022/01/Politik/</link>
        <guid isPermaLink="true">https://wenboli-cn-de.github.io/2022/01/Politik/</guid>
        
        <category>党政</category>
        
        
      </item>
    
      <item>
        <title>Win系统与Linux进行文件互传</title>
        <description>&lt;h2 id=&quot;1-使用工具winscp&quot;&gt;1. 使用工具Winscp&lt;/h2&gt;
&lt;p&gt;Win系统与Linux在局域网内进行文件互传可以通过Winscp软件进行。
值得注意的是Linux必须开启了ssh服务 对于树莓派来说，开启ssh是很容易的。
但是我的另一个Linux系统是XUbuntu（可以理解为小体积的Ubuntu，由于搭载系统的硬件是一台08年的破iMac, 
尝试Ubuntu无果后选择了替代系统，所以有些服务并未安装，比如此处的ssh服务。），其中并没有ssh服务，必须自己安装。&lt;/p&gt;
&lt;h2 id=&quot;2可能出现的问题&quot;&gt;2.可能出现的问题&lt;/h2&gt;
&lt;p&gt;连接过程可能会提示：
网络错误，连接被（Linux主机IP）拒绝&lt;/p&gt;

&lt;p&gt;Xubuntu安装ssh服务：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo apt-get install openssh-server&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;验证SSH服务器状态：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo systemctl status ssh&lt;/code&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Jan 2022 00:00:00 +0800</pubDate>
        <link>https://wenboli-cn-de.github.io/2022/01/Test0/</link>
        <guid isPermaLink="true">https://wenboli-cn-de.github.io/2022/01/Test0/</guid>
        
        <category>技术</category>
        
        
      </item>
    
  </channel>
</rss>
